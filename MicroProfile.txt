What is Quarkus?
  Quarkus is a framework to built on the top of Various java and JEE Standards.

What is JCP ?
 Java Community Process is non profitable organization whoes responsability is to standardize the java technology (java echo system).

if any java new version comes,JCP committe need to approve.

JSR-Java Specifcation Request.

Every JSR has unique no - JSR-223

What JEP (JDK Enhancement Proposal)
     The JDK Enhancement Proposal (or JEP) is a process drafted by Oracle Corporation for collecting proposals for enhancements to the Java Development Kit and OpenJDK.


Java Technology Classification

1.JSE
2.JEE
3.JME

1.JSE - Java Standard Edition
  -Java language Spec
  -Java VM Spec


2.JEE - Java Enterise Edition
 The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.

 -Application Development Specs
    JPA Spec  - Vendor netural ORM Solutions
    JSON Binding - JSON-B  
    Java Servlet 
    JAX-RS - Building Resfull API
    JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
    JTA  - Java Transaction API
 -Container Specs 
    How to create Enterprise grade applications

3.JME - Java Micro Edition
   For building Device Apps , Mobile Development.

Why JEE Spec failed In Modern Computing?

     JEE Spec was developed to build traditional "Monolothic distributed,transactional, secure Applications"


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

What if i want to build standard based microservices based On JEE?

                       "MicroProfile Specfication"



Birth of Project called MicroProfile

MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
..............................................................................................

Quarkus itself who does not implement Microprofile specification directly.
...............................................................................................
What is Quarkus?

 Quarkus is framwork built for building modern cloud and container native microservice,serverless architecture.

Quarkus Features:

1.Implements MicroProfile specification via smallRye project
2.Quarkus implements Reactive Stack via smallRye Muntiny
3.Quarkus implements non blocking architecture via Vert.x Engine
4.Quarkus supports Kubernets,docker ready images
5.Quarkus supports native apps via GraalVM
     -Mandrel: A specialized distribution of GraalVM for Quarkus
6.Quarkus supports hot reloading

Quarkus is collection many projects - modules

Modules:
1.core
2.web
3.data
4.messaging
5.reactive
6.cdi
etc...
.............................................................................................
				How to setup projects
............................................................................................

how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project Creations:

1.via Quarkus cli tool
2.via Maven
   2.1.via command line
   2.2.via https://code.quarkus.io/


Setup cli tool:
https://quarkus.io/get-started

Step : 1 : install jbang build tool via windows powershell with admin access

iex "& { $(iwr https://ps.jbang.dev) } app install --fresh --force quarkus@quarkusio"
[jbang] https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/2.7.5.Final/quarkus-cli-2.7.5.Final-runner.jar is not from a trusted source thus not running it automatically.

If you trust the url to be safe to run you can do one of the following

(1) Trust once: Add no trust, just download this time (can be run multiple times while cached)
(2) Trust limited url in future: https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/
(0) Cancel

[jbang] Type in your choice and hit enter. Will automatically select option (0) after 30 seconds.
1

[
Note : after installing , please close the shell/command prompt and relanuch

Step 2: Test quarkus working or not
 quarkus --help

Usage: quarkus [-ehv] [--verbose] [-D=<String=String>]... [COMMAND]
Options:
  -h, --help            Display this help message.
  -v, --version         Print version information and exit.
  -e, --errors          Display error messages.
      --verbose         Verbose mode.
  -D=<String=String>    Java properties

Commands:
  create                  Create a new project.
    app                   Create a Quarkus application project.
    cli                   Create a Quarkus command-line project.
    extension             Create a Quarkus extension project
  build                   Build the current project.
  dev                     Run the current project in dev (live coding) mode.
  extension, ext          Configure extensions of an existing project.
    list, ls              List platforms and extensions.
    categories, cat       List extension categories.
    add                   Add extension(s) to this project.
    remove, rm            Remove extension(s) from this project.
  registry                Configure Quarkus registry client
    list                  List enabled Quarkus registries
    add                   Add a Quarkus extension registry
    remove                Remove a Quarkus extension registry
  version                 Display version information.
  completion              bash/zsh completion:  source <(quarkus completion)


Step : 2: create quarkus app via Jbang tool

Open Normal Command Prompt:

quarkus create && cd code-with-quarkus


Step 3: lanuch in IDE -  Intellj Idea or vs code
 

Step 4: compile and lanuch in dev mode. using mvn

 ./mvnw compile quarkus:dev - linux/mac users

  mvnw compile quarkus:dev 
  or
  mvn  compile quarkus:dev
.............................................................................................
			MicroServices - Service Design -REST API Development
.............................................................................................
Quarkus is based on JEE Specfications and Micro Profile Specification.

1.JAX-RS
  It is spec from JEE 

Since JAX-RS is spec we need implementation.

1.RestEasy
2.Jersy

RestEasy:
  It is implemenation of JAX-RS specfication , used in side quarkus.

Quarkus has enchanced RestEasy for compatiable for native development

quarkus-resteasy
..............................................................................................

JAX-RS Terms:

1.Resource
   It represents domain model.

ProductResource
UserResource
CustomerResource

Declare Resource class annotate with @Path -  root path

API :
 HTTP Verbs(GET,POST,DELETE,PUT) - URL mapping.
...........................................................................................
package com.ibm.rs;

import javax.ws.rs.*;

@Path("/api/products")
public class ProductResource {
    //methods
    @Path("/list")
    @GET
    public String findAl() {
        return "FindAll Products!!!!!";
    }

    @POST
    @Path("/create")
    public String create() {
        return "Created...!!!!";
    }

    @PUT
    @Path("/update")
    public String update() {
        return "updated";
    }

    @Path("/remove")
    @DELETE
    public String remove() {
        return "Deleted";
    }
}

Task:
 Test the hot reloading feature is working or not.
 Test all endpoints are working or not.

............................................................................................

What is extension?

  extension is, project dependency - jar dependency.

By default , you can have extensions when create new project.

Think of Quarkus extensions as your project dependencies.

Extensions configure, boot and integrate a framework or technology into your Quarkus application. 

They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively.

How to manage extensions(dependency)?

managment means - add,removing,listing extensions

there are two ways

1.via maven or gradle 
2.via cli - quarkus

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext ls
Current Quarkus extensions installed:

? ArtifactId                                         Extension Name
? quarkus-resteasy                                   RESTEasy JAX-RS
? quarkus-resteasy-jackson                           RESTEasy Jackson


E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext rm resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been uninstalled

How to send JSON Payload as Response?

Quarks cant convert any object into JSON by default with help of "RestEasy" extension

Add resteasy-jackson

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext add resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been installed

Code:

package com.ibm.rs;

//Entity
public class User {
    private  int userId;
    private  String userName;

    public User() {
    }

    public User(int userId, String userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}

package com.ibm.rs;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/users")
public class UserResource {
    //send json
    @GET
    @Path("/list")
    @Produces(MediaType.APPLICATION_JSON)
    public User findUser() {
        User user = new User(1, "Subramanian Murugan");
        return user;
    }
}

Note:
  Quarkus applies hot reloading feature, when we add extension, that means we dont need to restart server even after adding any dependency.
...........................................................................................
				JAX-RS Parameters
...........................................................................................
@MatrixParam 
   Extracts the value of a URI matrix parameter.
@QueryParam 
  Extracts the value of a URI query parameter.
@PathParam 
  Extracts the value of a URI template parameter.
@CookieParam
  Extracts the value of a cookie.
@HeaderParam
  Extracts the value of a header.
@Context
  Injects an instance of a supported resource
	

package com.ibm.rs.params;

package com.ibm.rs.params;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/api/myproducts")
public class ProductResource {

    //http://localhost:8080/api/products/10
    @Path("/{productId}")
    @GET
    public String findById(@PathParam("productId") String productId) {
        return productId;
    }

    //http://localhost:8080/product/filter?category=sports
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") String category) {
        System.out.println("");
        return category;
    }

    //Matrix Params
    //http://localhost:8080/api/myproducts/product;name=book;title=Java
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/product")
    public String getBookDetails(@MatrixParam("name") String name, @MatrixParam("title") String title) {
        System.out.println("");
        return name + " " + title;
    }
}


package com.ibm.rs.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;

@Path("/api/containerResource")
public class ContainerResouces {

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/urls")
    public String getUriInfo(@Context UriInfo uriInfo) {
        System.out.println(uriInfo.getAbsolutePath() + " " + uriInfo.getRequestUri());
        return uriInfo.getAbsolutePath() + " " +uriInfo.getRequestUri();
    }

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/headers")
    public String getHeaders(@Context HttpHeaders headers) {
        System.out.println(headers.getRequestHeaders());
        return "headers Information";
    }
}

Other Paramters:

1.FormParameters
@FormParam @Form
2.CookieParameter
@CookieParam
.............................................................................................
				  DefaultValues for Path

if you dont pass Query parameters ,the default values can be assigned.

//localhost:8080/api/myproducts/filter => output phone
//localhost:8080/api/myproducts/filter?category=books => output books

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") @DefaultValue("phone") String  category) {
        System.out.println("");
        return category;
    }
.............................................................................................
Assignment : 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection
.............................................................................................
				 Response Types
.............................................................................................

JAX-RS api can return any of one the type
 - String  - plain/text
 - Objects - application/json
 - Void    - no return type -  only status
 - Response - Response Object 


Basic Response Types: String,void,Object
package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook(){
        return "Book";
    }

    @GET
    @Path("/show")
    public void showBook(){
        System.out.println("show Book");
    }
    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook(){
        return new Book("Quarkus");
    }
}


Recommendations:

1.You can use String
2.Dont use void
3.YOu can use Object as response type


Limitions of Object as Response

-if you want to customize the Response we cant,for eg if you want to add some custom headers
like tokens,urls,resourceinformation.

Reponse Object

Response;

 Object used to send "payload-data" along with meta data (http code,otherinformation)

HTTP Status codes:

-> informational response - 100 to 199
-> success response -  200-299
-> Redirects  - 300-399
-> client errors - 400-499
-> server errrors - 500-599

package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response save() {
        Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}

How to post json to REST API(Save)

package com.ibm.rs.response.type;

public class Book {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Book() {
    }

    public Book(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                '}';
    }
}

package com.ibm.rs.response.type;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON) //output type
    @Consumes(MediaType.APPLICATION_JSON)  //input type
    public Response save(Book book) {
        //Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}















