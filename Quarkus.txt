What is Quarkus?
  Quarkus is a framework to built on the top of Various java and JEE Standards.

What is JCP ?
 Java Community Process is non profitable organization whoes responsability is to standardize the java technology (java echo system).

if any java new version comes,JCP committe need to approve.

JSR-Java Specifcation Request.

Every JSR has unique no - JSR-223

What JEP (JDK Enhancement Proposal)
     The JDK Enhancement Proposal (or JEP) is a process drafted by Oracle Corporation for collecting proposals for enhancements to the Java Development Kit and OpenJDK.


Java Technology Classification

1.JSE
2.JEE
3.JME

1.JSE - Java Standard Edition
  -Java language Spec
  -Java VM Spec


2.JEE - Java Enterise Edition
 The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.

 -Application Development Specs
    JPA Spec  - Vendor netural ORM Solutions
    JSON Binding - JSON-B  
    Java Servlet 
    JAX-RS - Building Resfull API
    JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
    JTA  - Java Transaction API
 -Container Specs 
    How to create Enterprise grade applications

3.JME - Java Micro Edition
   For building Device Apps , Mobile Development.

Why JEE Spec failed In Modern Computing?

     JEE Spec was developed to build traditional "Monolothic distributed,transactional, secure Applications"


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

What if i want to build standard based microservices based On JEE?

                       "MicroProfile Specfication"



Birth of Project called MicroProfile

MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
..............................................................................................

Quarkus itself who does not implement Microprofile specification directly.
...............................................................................................
What is Quarkus?

 Quarkus is framwork built for building modern cloud and container native microservice,serverless architecture.

Quarkus Features:

1.Implements MicroProfile specification via smallRye project
2.Quarkus implements Reactive Stack via smallRye Muntiny
3.Quarkus implements non blocking architecture via Vert.x Engine
4.Quarkus supports Kubernets,docker ready images
5.Quarkus supports native apps via GraalVM
     -Mandrel: A specialized distribution of GraalVM for Quarkus
6.Quarkus supports hot reloading

Quarkus is collection many projects - modules

Modules:
1.core
2.web
3.data
4.messaging
5.reactive
6.cdi
etc...
.............................................................................................
				How to setup projects
............................................................................................

how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project Creations:

1.via Quarkus cli tool
2.via Maven
   2.1.via command line
   2.2.via https://code.quarkus.io/


Setup cli tool:
https://quarkus.io/get-started

Step : 1 : install jbang build tool via windows powershell with admin access

iex "& { $(iwr https://ps.jbang.dev) } app install --fresh --force quarkus@quarkusio"
[jbang] https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/2.7.5.Final/quarkus-cli-2.7.5.Final-runner.jar is not from a trusted source thus not running it automatically.

If you trust the url to be safe to run you can do one of the following

(1) Trust once: Add no trust, just download this time (can be run multiple times while cached)
(2) Trust limited url in future: https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/
(0) Cancel

[jbang] Type in your choice and hit enter. Will automatically select option (0) after 30 seconds.
1

[
Note : after installing , please close the shell/command prompt and relanuch

Step 2: Test quarkus working or not
 quarkus --help

Usage: quarkus [-ehv] [--verbose] [-D=<String=String>]... [COMMAND]
Options:
  -h, --help            Display this help message.
  -v, --version         Print version information and exit.
  -e, --errors          Display error messages.
      --verbose         Verbose mode.
  -D=<String=String>    Java properties

Commands:
  create                  Create a new project.
    app                   Create a Quarkus application project.
    cli                   Create a Quarkus command-line project.
    extension             Create a Quarkus extension project
  build                   Build the current project.
  dev                     Run the current project in dev (live coding) mode.
  extension, ext          Configure extensions of an existing project.
    list, ls              List platforms and extensions.
    categories, cat       List extension categories.
    add                   Add extension(s) to this project.
    remove, rm            Remove extension(s) from this project.
  registry                Configure Quarkus registry client
    list                  List enabled Quarkus registries
    add                   Add a Quarkus extension registry
    remove                Remove a Quarkus extension registry
  version                 Display version information.
  completion              bash/zsh completion:  source <(quarkus completion)


Step : 2: create quarkus app via Jbang tool

Open Normal Command Prompt:

quarkus create && cd code-with-quarkus


Step 3: lanuch in IDE -  Intellj Idea or vs code
 

Step 4: compile and lanuch in dev mode. using mvn

 ./mvnw compile quarkus:dev - linux/mac users

  mvnw compile quarkus:dev 
  or
  mvn  compile quarkus:dev
.............................................................................................
			MicroServices - Service Design -REST API Development
.............................................................................................
Quarkus is based on JEE Specfications and Micro Profile Specification.

1.JAX-RS
  It is spec from JEE 

Since JAX-RS is spec we need implementation.

1.RestEasy
2.Jersy

RestEasy:
  It is implemenation of JAX-RS specfication , used in side quarkus.

Quarkus has enchanced RestEasy for compatiable for native development

quarkus-resteasy
..............................................................................................

JAX-RS Terms:

1.Resource
   It represents domain model.

ProductResource
UserResource
CustomerResource

Declare Resource class annotate with @Path -  root path

API :
 HTTP Verbs(GET,POST,DELETE,PUT) - URL mapping.
...........................................................................................
package com.ibm.rs;

import javax.ws.rs.*;

@Path("/api/products")
public class ProductResource {
    //methods
    @Path("/list")
    @GET
    public String findAl() {
        return "FindAll Products!!!!!";
    }

    @POST
    @Path("/create")
    public String create() {
        return "Created...!!!!";
    }

    @PUT
    @Path("/update")
    public String update() {
        return "updated";
    }

    @Path("/remove")
    @DELETE
    public String remove() {
        return "Deleted";
    }
}

Task:
 Test the hot reloading feature is working or not.
 Test all endpoints are working or not.

............................................................................................

What is extension?

  extension is, project dependency - jar dependency.

By default , you can have extensions when create new project.

Think of Quarkus extensions as your project dependencies.

Extensions configure, boot and integrate a framework or technology into your Quarkus application. 

They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively.

How to manage extensions(dependency)?

managment means - add,removing,listing extensions

there are two ways

1.via maven or gradle 
2.via cli - quarkus

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext ls
Current Quarkus extensions installed:

? ArtifactId                                         Extension Name
? quarkus-resteasy                                   RESTEasy JAX-RS
? quarkus-resteasy-jackson                           RESTEasy Jackson


E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext rm resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been uninstalled

How to send JSON Payload as Response?

Quarks cant convert any object into JSON by default with help of "RestEasy" extension

Add resteasy-jackson

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext add resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been installed

Code:

package com.ibm.rs;

//Entity
public class User {
    private  int userId;
    private  String userName;

    public User() {
    }

    public User(int userId, String userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}

package com.ibm.rs;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/users")
public class UserResource {
    //send json
    @GET
    @Path("/list")
    @Produces(MediaType.APPLICATION_JSON)
    public User findUser() {
        User user = new User(1, "Subramanian Murugan");
        return user;
    }
}

Note:
  Quarkus applies hot reloading feature, when we add extension, that means we dont need to restart server even after adding any dependency.
...........................................................................................
				JAX-RS Parameters
...........................................................................................
@MatrixParam 
   Extracts the value of a URI matrix parameter.
@QueryParam 
  Extracts the value of a URI query parameter.
@PathParam 
  Extracts the value of a URI template parameter.
@CookieParam
  Extracts the value of a cookie.
@HeaderParam
  Extracts the value of a header.
@Context
  Injects an instance of a supported resource
	

package com.ibm.rs.params;

package com.ibm.rs.params;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/api/myproducts")
public class ProductResource {

    //http://localhost:8080/api/products/10
    @Path("/{productId}")
    @GET
    public String findById(@PathParam("productId") String productId) {
        return productId;
    }

    //http://localhost:8080/product/filter?category=sports
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") String category) {
        System.out.println("");
        return category;
    }

    //Matrix Params
    //http://localhost:8080/api/myproducts/product;name=book;title=Java
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/product")
    public String getBookDetails(@MatrixParam("name") String name, @MatrixParam("title") String title) {
        System.out.println("");
        return name + " " + title;
    }
}


package com.ibm.rs.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;

@Path("/api/containerResource")
public class ContainerResouces {

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/urls")
    public String getUriInfo(@Context UriInfo uriInfo) {
        System.out.println(uriInfo.getAbsolutePath() + " " + uriInfo.getRequestUri());
        return uriInfo.getAbsolutePath() + " " +uriInfo.getRequestUri();
    }

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/headers")
    public String getHeaders(@Context HttpHeaders headers) {
        System.out.println(headers.getRequestHeaders());
        return "headers Information";
    }
}

Other Paramters:

1.FormParameters
@FormParam @Form
2.CookieParameter
@CookieParam
.............................................................................................
				  DefaultValues for Path

if you dont pass Query parameters ,the default values can be assigned.

//localhost:8080/api/myproducts/filter => output phone
//localhost:8080/api/myproducts/filter?category=books => output books

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") @DefaultValue("phone") String  category) {
        System.out.println("");
        return category;
    }
.............................................................................................
Assignment -1: 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection
.............................................................................................
				 Response Types
.............................................................................................

JAX-RS api can return any of one the type
 - String  - plain/text
 - Objects - application/json
 - Void    - no return type -  only status
 - Response - Response Object 


Basic Response Types: String,void,Object
package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook(){
        return "Book";
    }

    @GET
    @Path("/show")
    public void showBook(){
        System.out.println("show Book");
    }
    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook(){
        return new Book("Quarkus");
    }
}


Recommendations:

1.You can use String
2.Dont use void
3.YOu can use Object as response type


Limitions of Object as Response

-if you want to customize the Response we cant,for eg if you want to add some custom headers
like tokens,urls,resourceinformation.

Reponse Object

Response;

 Object used to send "payload-data" along with meta data (http code,otherinformation)

HTTP Status codes:

-> informational response - 100 to 199
-> success response -  200-299
-> Redirects  - 300-399
-> client errors - 400-499
-> server errrors - 500-599

Response:

Response class is abstract class contains two category of api

public abstract Object getEntity();
public abstract int getStatus();


Builder Class:

public static ResponseBuilder status(int status)
public static ResponseBuilder ok()
public static ResponseBuilder ok(Object entity)
public static ResponseBuilder created()
public static ResponseBuilder accepted()
public static ResponseBuilder noContent()

package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response save() {
        Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}

How to post json to REST API(Save)

package com.ibm.rs.response.type;

public class Book {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Book() {
    }

    public Book(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                '}';
    }
}

package com.ibm.rs.response.type;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON) //output type
    @Consumes(MediaType.APPLICATION_JSON)  //input type
    public Response save(Book book) {
        //Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}
.............................................................................................
................................................................................................				Status Codes And RestFul Api Design
..............................................................................................
Status Code : 100 to 500

1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required
..............................................................................................
				  Negoation
..............................................................................................

What is Negoation?
 Agreeement between server and client what they can serve.

if client asks server that give me xml, means the server should able to give xml, if not it will give  response- not able to process your.

Content negotiation allows for an HTTP server to respond to different types of clients.

Many modern clients expect a JSON response, but there may be a need to format responses differently, maybe XML for older clients or a binary format for newer ones.


If the server is unable to provide the desired format, it will respond with a status code of 406, “Not Acceptable.”

Types of Negoation:

1.Content-Negotation
2.Language Negoation
3.Encoding Negoation


How to implement  Negotation?

Via Headers


Client Request:

Accept-*

Content Negotation
Accept: application/json,application/xml;

Language Negotation:
Accept-Language: fr

Encoding Negotation:
Accept-Encoding : gzip,deflate
..............................................................................................

Negotitation is just like a dialog between client and server.


At a high level, the conversation looks like this:

Client:
Hey Server!
I’d like to look at https://api.example.com/user/123.
I need your response in JSON.

	Server:
No Problem Client! Here is that response…​


Client:
Hey Server! I need https://api.example.com/user/123, preferably in JSON!
But, 😩 I’ll take XML if that’s all you have.
I also need the info in English or French.
Oh, please zip up the contents too.

GET /user/123 HTTP/1.1
Accept: application/json,application/xml;q=0.9
Accept-Encoding: gzip
Accept-Language: en,fr
Host: api.example.com
User-Agent: Client/2.0


Server:
Hey Client!
All I have is XML (sorry about that), the response is in English,
and I was able to zip it; here you go…​

                                        HTTP/1.1 200 OK
                                        Content-Type: application/xml
                                        Content-Encoding: gzip
                                        Content-Language: en

                                        <user id="123">
                                          ...
                                        </user>

..............................................................................................
Negotiation is bi directional.

Client ask with help of "Accept -*" Headers, Server will resonse with "Content-*" Headers

package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }
}


http://localhost:8080/negotiation/content

Could not find MessageBodyWriter for response object of type: com.ibm.rs.User of media type:
application/xml;charset=UTF-8


Steps:
1.Add new Dependency /extension


quarkus  ext add resteasy-jaxb
 <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-jaxb</artifactId>
</dependency>

2.We have to add @XmlRootElement

package com.ibm.rs;

import javax.xml.bind.annotation.XmlRootElement;

//Entity
@XmlRootElement
public class User {
    private  int userId;
    private  String userName;

    public User() {
    }

    public User(int userId, String userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}

3.REST api which supports multi format
package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }
}

3.How to test api with multi format 

open postman or any http client.

send request

URL -http:localhost:8080/negotiation/content
Method - GET
Client/Request HTTP Headers: Accept : application/json or Accept : application/xml

Response :
Request : Accept:application/json
Status : 200 OK
{
    "userId": 1,
    "userName": "admin"
}

Request : Accept: application/xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<user>
    <userId>1</userId>
    <userName>admin</userName>
</user>

Request: Accept :application/atom+xml

Response would be 
406 Not Acceptable
The server not able to send response what client is looking for.

Client uses Accept-* header

Server uses Content-* header
..............................................................................................
				 When Client Sends Data to Server
..............................................................................................

Client is sending data in the form of json / xml or any format, server should able to process that.
content-type and annotation

@Consumes - It defines the server acceptable content.
    @POST
    @Path("/create")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response create(User user) {
        System.out.println("User " + user);
        return Response.status(201).entity("Created").build();
    }
..............................................................................................
..............................................................................................						HTTP encoding
.............................................................................................

What is Content Encoding?

 if Server sends data, it can send directly

Compression Algorthim:

1.gzip
2.deflate

How to enable compression algorithm in quarkus?

By default Quarkus web container does not enable compression feature, we need to enable it.

application.properties file
  You can configure global setting for application.
quarkus.http.enable-compression=true
quarkus.resteasy.gzip.enabled=true
quarkus.resteasy.gzip.max-input=10M


package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }

        @POST
        @Path("/create")
        @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
        public Response create(User user) {
            System.out.println("User " + user);
            return Response.status(201).entity("Created").build();
        }
}


Request:

GET    /localhost:8080/negotiation/content
Accept-Encoding :gzip

Response:
content-encoding :gzip
content-length:54

..............................................................................................
			    Language Negotation
.............................................................................................

How Quarkus can give data in various data language formats. - Internatlazation and locationazation.

package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.*;
import javax.ws.rs.core.*;
import java.util.List;
import java.util.Locale;

@Path("/negotiation")
public class ContentNegotiationResource {
    //language
    // GET /negotiation/lang
    //Accept-language : en

    @Path("/lang")
    @GET
    public Response getLang(@Context Request request) {

        List<Variant> variants = Variant.VariantListBuilder
                .newInstance()
                .languages(Locale.ENGLISH, Locale.GERMAN)
                .build();


        Variant variant = request.selectVariant(variants);

        if (variant == null) {
            return Response.notAcceptable(variants).build();
        }
        String language = variant.getLanguageString();
        return Response.ok(language)
                .header(HttpHeaders.CONTENT_LANGUAGE, language)
                .build();
    }
}

Request

Request:

GET    /localhost:8080/negotiation/lang
Accept-language :en    or de

Response:
content-language : en
.............................................................................................
			        Resource Locators and Sub Resources
............................................................................................

Objective:
 if you are designing rest api for various resources,if you want to design centeralized request processing.

eg:
 CustormerResource
 PaymentResource 
 CardResource
 UserResource
 ProductResource

eg:
Normal request and response flow

Client----GET  /api/customer----------------------CustomerResource
Client----GET  /api/payment-----------------------PaymentResource

Using Resouce Locators

Client----GET  /api/customer----------------------              CustomerResource
						Application --|
Client----GET  /api/payment-----------------------               PaymentResource
                                                    |                |
                                                 main Resource    SubResources   
 


Main Resouce:
package com.ibm.rs.resoucelocators;

import javax.ws.rs.Path;

@Path("/api/ibm")
public class Application {
    //payment
    @Path("/payments")
    public PaymentResource getPaymentResource() {
        return new PaymentResource();
    }
    //Services
    @Path("/services")
    public ProductService getProductService(){
          return new ProductService();
    }
}

Sub Resouces:
package com.ibm.rs.resoucelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class ProductService {
    @GET
    public String getPayments() {
        return "Service  resource";
    }
    @GET
    @Path("{id}")
    public String getPaymentById(@PathParam("id") String id) {
        return "Services resource by id" + id;
    }
}
package com.ibm.rs.resoucelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class PaymentResource {
    @GET
    public String getPayments() {
        return "Payment resource";
    }
    @GET
    @Path("{id}")
    public String getPaymentById(@PathParam("id") String id) {
        return "Payments resource by id" + id;
    }
}

Errors can be reported to a client either by creating and returning the appropriate
Response object or by throwing an exception.

Response Types:

1.SUCCESS Response
2.ERROR Response

How to handle / Convert ERRORS/Exceptions into HTTP Response Object?

 public Response getResponse(){

     return Response.ok().build();
 }

According to Application, Exception can be

1.System Exception :
  Exception thrown by jvm - NumberFormat,NullPointerException,ClassCastException.

2.Application Exception
   
  UserNotFoundException
  PasswordMissMatchException
  ...
public boolean validate(){

  if(passwordmatch){


  }
  else{ 
       throw new PasswordMismatchException("password does not match");
  } 
}
JAX-RS also provides the javax.ws.rs.WebApplicationException. 
This can be thrown by application code and automatically processed by JAX-RS without
having to write an explicit mapper.

WebApplicationException can be converted into Response Object.

Thrown exceptions are handled by the JAX-RS runtime if you have registered an exception mapper. 
Exception mappers can convert an exception to an HTTP response. 
If the thrown exception is not handledby a mapper, it is propagated and handled by the container (i.e., servlet) JAX-RS is running within.


package com.ibm.rs.exceptionhandling;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {
    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return Response.ok("Sucess" + id).build();
    }
}

if you run this code with  

GET  /localhost:8080/myerrors/100
2022-04-04 11:47:02,439 ERROR [org.jbo.res.res.i18n] (executor-thread-0) RESTEASY002010: Failed to execute: javax.ws.rs.WebApplicationException: HTTP 404 Not Found
        at com.ibm.rs.exceptionhandling.ErrorResource.getResponse(ErrorResource.java:15)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass.getResponse$$superforward1(Unknown Source)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass$$function$$1.apply(Unknown Source)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:54)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:49)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(Unknown Source)
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:41)
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass.getResponse(Unknown Source)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:170)
        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:130)
        at org.jboss.resteasy.core.ResourceMethodInvoker.internalInvokeOnTarget(ResourceMethodInvoker.java:660)
        at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTargetAfterFilter(ResourceMethodInvoker.java:524)
        at org.jboss.resteasy.core.ResourceMethodInvoker.lambda$invokeOnTarget$2(ResourceMethodInvoker.java:474)
        at org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364)
/////////////////////////////////////////////////////////////////////////////////////////////

The above error we need to handle by converting into response.

In order to convert Exception into Proper Response, JAX-RS provides , Mapper class.

Mapper class will convert any expception into Success like Response, so that it wont throw any Errors.

Exception Mapper class:

Steps:

1.You have to declare Mapper class

2.You have to annotate with @Provider Annotation.

@Provider
public class WebApplicationMapper {
}

3.You have to extends ExceptionMapper<ExceptionType>


package com.ibm.rs.exceptionhandling;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
//
//class CustomerIdNotFoundException extends RuntimeException {
//     public CustomerIdNotFoundException(){
//            super();
//     }
//    public CustomerIdNotFoundException(String message){
//        super(message);
//    }
//}
//
//@Provider
//class CustomerExceptionMapper implements ExceptionMapper<CustomerIdNotFoundException> {
//    @Override
//    public Response toResponse(CustomerIdNotFoundException e) {
//        return null;
//    }
//}

@Provider
public class WebApplicationMapper implements ExceptionMapper<WebApplicationException> {
    @Override
    public Response toResponse(WebApplicationException e) {
        // return Response.noContent().build();
        return Response.status(404)
                .entity(e.getMessage())
                .header("err", e.getResponse()
                        .getStatus()).build();
    }
}
..............................................................................................
				  Dependency Injection - IOC
..............................................................................................

What is IOC?
 Inversion of Control is design pattern for creating depandent objects and injecting into another.

How IOC is implemented in Spring?
 Spring Container is the reference implemnetation of IOC design pattern

How IOC is implemented in Quarkus?
  Quarkus uses JEE spec called CDI context Dependency Injection

What is CDI?
  CDI is JEE Spec? -Jakarta Contexts and Dependency Injection

Quarkus and CDI ?
 Quarkus has not implemented 100% CDI spec due to some reasons.

  "Quarkus ArC" is a build-time oriented dependency injection based on CDI 2.0.

JEE CDI Vs Quarkus CDI:
......................

JEE CDI "resolves" bean dependency during runtime of an application,after deployment, if something goes wrong, errors are reported only during runtime.

Quarkus CDI uses a model called "Build Time"
   During application build process, if there is any dependency missmatch related errors are reported.

Build-time Processing Benefits and Drawbacks:
..............................................

Fail Fast
  Beans and dependencies are validated during the build so that your application can never fail in production with common problems such as AmbiguousResolutionException or UnsatisfiedResolutionException.

Instant Startup
  When the app starts ArC just loads all the metadata and initializes some internal structures. There is no need to analyze the application classes again. This means negligible startup overhead.
 
Minimized Runtime
  In Quarkus 0.19, ArC plus integration runtime consist of 72 classes and occupies ~ 140 KB in jars. Weld 3.1.1 (CDI Reference Implementation) core is roughly 1200 classes and approx. 2 MB jar. In other words, ArC runtime takes approx. 7% of the Weld runtime in terms of number of classes and jar footprint.

Optimized Code Paths and Metadata Structures
  When generating the metadata classes ArC can sometimes produce leaner and smarter logic because it has the whole application analyzed already. 

Core Features of CDI:

1.Bean: What is Bean?
  Bean is java object

Types of Beans:

1.Application Beans(pojos)
   Objects are created by developer 
   Objects life cycle is managed by developer and JVM

2.Container managed Bean
   Objects created by the Container

What is container?
   Container is runtime where quarkus apps are running.
 
  Object life cycle are managed by Runtime 

What are the advantages of Container Managed Bean?

>The developer can focus application logic.
.............................................................................................
				 CDI implemenation

CDI is implemented via "Annotations"

Apis in cdi:

1.javax.inject
2.javax.enterprise.inject - core di apis
3.javax.enterprise.context - scope and contextuaal apis
4.javax.enterprise.events -  publishing events and listening events-  container wide event driven programming
5.javax.enterprise.util
6.javax.interceptor

Common Annoations:

1.@Inject  
2.@Qualifer
3.LifeCycle of Bean
   @ApplicationScoped
   @SessionScoped
   @RequestScoped
   @SingleTon
 
4.@Observes - event listner


package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

//Bean
@ApplicationScoped
public class HelloService {
    public String sayHello() {
        return "Hello!!!";
    }
}


package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/greeter")
public class GreeterResource {
    //DI - field
    @Inject
    private HelloService helloService;

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
............................................................................................

Assignment -2: 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

New Features to be added:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI
.............................................................................................
   				CDI and Resource Locator


if a sub resouces has CDI annotation, if there  is any dependency.we need to use different annotations.

Main Resource

Old style:
    @Path("/services")
    public ProductService getProductService(){
          return new ProductService();
    }
This code will not work , which will throw NullPointerException, the reason is CDI build time process. here object creation happens runtime.

Solution;
@Context - It is used to inject any container specific features.

ResourceContext :
      Get a resolved instance of a resource or sub-resource class.

The resolved resource instance is properly initialized in the context of the current request processing scope.

 The scope of the resolved resource instance depends on the managing container. For resources managed by the runtime container the default scope is per-request.


Resource:
package com.ibm.rs.resoucelocators;

import com.ibm.rs.di.GreeterResource;

import javax.ws.rs.Path;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;

@Path("/api/ibm")
public class Application {
    @Context
    ResourceContext resourceContext;
   
    @Path("/greeter")
    public GreeterResource getGreeterResource(){
        return resourceContext.getResource(GreeterResource.class);
    }
}

package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
    //DI - field
    @Inject
    private HelloService helloService;

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
..............................................................................................

			Bean Creation Exception-UnsatisfiedResolutionException


javax.enterprise.inject.UnsatisfiedResolutionException: Unsatisfied dependency for type com.ibm.rs.di.HelloService and qualifiers [@Default]
	- java member: com.ibm.rs.di.GreeterResource#helloService
	- declared on CLASS bean [types=[com.ibm.rs.di.GreeterResource, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.GreeterResource]
	at io.quarkus.arc.processor.Beans.resolveInjectionPoint(Beans.java:428)
	at io.quarkus.arc.processor.BeanInfo.init(BeanInfo.java:524)
	at io.quarkus.arc.processor.BeanDeployment.init(BeanDeployment.java:260)
	at io.quarkus.arc.processor.BeanProcessor.initialize(BeanProcessor.java:134)
	at io.quarkus.arc.deployment.ArcProcessor.validate(ArcProcessor.java:462)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)


This exception is thrown when bean is not created -  
  due to 
    -no bean class  not present in the class path
    -you may forgot to annotate using lifecycle annotations -@ApplicationScoped...


eg:
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}
 @Inject
 HelloService helloService;

..............................................................................................
                            Types of Injection in Quarkus  -Inection Points

1.Field Injection
2.Setter Injection
3.Constructor injection


Setter Injection
package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
   //setter injection
    private HelloService helloService;

    @Inject
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}

///
constructor injection:
package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
    //DI - field
//    @Inject
//    private HelloService helloService;

    //setter injection
//    private HelloService helloService;
//
//    public GreeterResource() {
//    }

    //constructor Injection
    private HelloService helloService;

    //    @Inject
//    public GreeterResource(HelloService helloService) {
//        this.helloService = helloService;
//    }

//without Inject annotation also works
    public GreeterResource(HelloService helloService) {
        this.helloService = helloService;
    }

//

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
.............................................................................................
				Quarkus and Type based Implementation 
.............................................................................................

Quarkus is always based on type based injection not implemenation based.

Steps : 1 declare interface.

package com.ibm.rs.di;

public interface NumberGenerator {
    //Generate ISBN Number
    String generateNumber();
}

Step 2:  implement interface
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@ApplicationScoped
public class IsbnGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "15-87654" + Math.abs(new Random().nextInt());
    }
}

Step 3: declare book Service:
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

@ApplicationScoped
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}

Step 5: Declare Book Resource
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/book")
public class BookResource {
    @Inject
    BookService bookService;

    @GET
    public Response createBook(){
        return Response.ok(bookService.createBook()).build();
    }
}
..............................................................................................
			   Interface DI with Mulitiple Implementations
..............................................................................................


Step : 1 declare interface
package com.ibm.rs.di;

public interface Greeter {
    String sayGreet();
}

Step 2 : declare multiple implementations

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class Hai implements Greeter {
    @Override
    public String sayGreet() {
        return "Hai";
    }
}

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class Hello implements Greeter {
    @Override
    public String sayGreet() {
        return "Hello";
    }
}

Step 3: Resource Class with Greeter Dependency

package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/greeter/greet")
public class GreeterDIResource {
    @Inject
    private Greeter greeter;

    @GET
    public String sayGreet() {
        return greeter.sayGreet();
    }

}

When you run this code , you will get 

javax.enterprise.inject.AmbiguousResolutionException: Ambiguous dependencies for type com.ibm.rs.di.Greeter and qualifiers [@Default]
	- java member: com.ibm.rs.di.GreeterDIResource#greeter
	- declared on CLASS bean [types=[java.lang.Object, com.ibm.rs.di.GreeterDIResource], qualifiers=[@Default, @Any], target=com.ibm.rs.di.GreeterDIResource]
	- available beans:
		- CLASS bean [types=[com.ibm.rs.di.Greeter, com.ibm.rs.di.Hello, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.Hello]
		- CLASS bean [types=[com.ibm.rs.di.Hai, com.ibm.rs.di.Greeter, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.Hai]

here we need to tell the quarkus which implementation bean you want.


How to solve this problem?

Qualifiers
   Injecting Qualified beans which you want bean implemenation you want.

Is there any default qualifier?

Yes

@Default

if there is only one implementation, injection works using @Default qualifier.

if there is more than one implementation , container will throw AmbiguousResolutionException

How to write Qualifier?

We have to write custom  Qualifer annotation

Steps: 

1.Qualifier for Hai
import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface HaiQualifier{
}

2.Qualifier for Hello

package com.ibm.rs.di;

import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface HaiQualifier{
}


3.Annotate Bean classes with Qualifiers

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@HelloQualifier
@ApplicationScoped
public class Hello implements Greeter {
    @Override
    public String sayGreet() {
        return "Hello";
    }
}
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@HaiQualifier
@ApplicationScoped
public class Hai implements Greeter {
    @Override
    public String sayGreet() {
        return "Hai";
    }
}

4.Inject beans into service or resource
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/greeter/greet")
public class GreeterDIResource {

    //this works only if there is only one implementation
//    @Inject @Default
//    private Greeter greeter;
//    @Inject
//    @HaiQualifier
//    private Greeter haigreeter;
//
//    @Inject
//    @HelloQualifier
//    private Greeter hellogreeter;

    //code refactoring without @Inject itself it works
    @HaiQualifier
    private Greeter haigreeter;

    @HelloQualifier
    private Greeter hellogreeter;

    @GET
    public String sayGreet() {
        return haigreeter.sayGreet() + " " + hellogreeter.sayGreet();
    }

}
...........................................................................................
				Bean Scopes
...........................................................................................
1.@ApplicationScoped
     Bean is created and kept entire life of application
     Only one time is created - singleton
     A single bean instance is used for the application and shared among all injection points. 
     The instance is created lazily, i.e. once a method is invoked upon the "client proxy".

2.@SingleTon
      -only one instance per container

Applicationscope vs singleton

-singleton beans are eagerly created
-application beans are lazy - uses a factory -client proxy
-singleton is some what performance good.Applicationscope uses delegation pattern to delegate  objects to proxy classes
-Singletons cant be used to create Mock using QuarksMock under test

     
2.Request,Session
   -A bean can be bound to single request cycle-  mostly used in  dynamic webapps
    eg: Spring MVC,Struts
   -Session scope 
     single user multiple requests.

@RequestScoped :
  In the subresource if you refer resource inside MainResource.

PaymentApp
    -
     @RequestScoped
     CreditCardResource
..............................................................................................
..............................................................................................
			Types of beans with respect to data injection
..............................................................................................

1.class beans
  ...variables and methods itself can be treated as dependency
2.Producer methods
3.Producer fields
.....................
4.Syntenetics beans


1.class Bean:
  Bean is created out class.

@ApplicationScoped
public class BookService {} 

@Inject
BookService bookService

2.Producer fields  && Producer methods
   We can inject any instance variable and methods as dependency.

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import java.util.ArrayList;
import java.util.List;

@ApplicationScoped
public class Producers {
    //instance variable ; going to be as dependency to some other classes
    @Produces
    double price = 1000.00;

    //instance method ; going to be as dependency to some other class
    @Produces
    List<String> topics(){
        List<String> topics = new ArrayList<>();
        topics.add("cdi");
        topics.add("configuration");
        topics.add("RestEasy");
        return topics;
    }
}
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;
import java.util.List;

@Path("/producer")
public class ProducerDI {

    @Inject
    double price;
    @Inject
    List<String> topics;


    @GET
    @Path("/price")
    public Response getPrice() {
        return Response.ok().entity(price).build();
    }
    @GET
    @Path("/topics")
    public Response getTopics() {
        return Response.ok().entity(topics).build();
    }
}
..............................................................................................
				Life cycle Hooks and Beans
.............................................................................................

@PostConstruct
@PreDestroy

package com.ibm.rs.di;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Singleton;

@ApplicationScoped
//@Singleton
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;
    
    @PostConstruct
    public void init(){
        System.out.println("INIT");
    }
    @PreDestroy
    public void destroy(){
        System.out.println("Destroy");
    }

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}
..............................................................................................
				  Interceptors
..............................................................................................
    
What is concern?
   concern means features like transaction,security,logging

Cross cutting means, removing these concerns from the application logic.

How to cross cutting concerns?
 There is spec all "java interceptors" 

How to define interceptor and bind with api?

Step 1: 
Define custom Annotation and annotate with @InterceptorBinding , which is going to act as bridge between "Interceptor" and Service biz logic.

package com.ibm.rs.di.interceptors;

import javax.interceptor.InterceptorBinding;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Inherited
@InterceptorBinding
@Retention(RUNTIME)
@Target({METHOD, TYPE})
public @interface LogEvent {
}

Step 2: define Interceptor

Declare class and annotate with @Interceptor

Have method and annotate with @AroundInvoke - gets called when ever biz method is called
Bind With @LogEvent -  InterceptorBinding Annotation

package com.ibm.rs.di.interceptors;

import javax.interceptor.AroundInvoke;
import javax.interceptor.Interceptor;
import javax.interceptor.InvocationContext;
import java.util.logging.Logger;

@Interceptor
@LogEvent
public class BookServiceInterceptor {

    private Logger logger;

    @AroundInvoke
    public Object logEvent(InvocationContext invocationContext) throws Exception {
        logger = Logger.getLogger(invocationContext.getTarget().getClass().getName());
        System.out.println("log.........");
        logger.info("Method: " + invocationContext.getMethod().getName());
        logger.info("Arguments: " + invocationContext.getParameters());
        logger.info("Executing the called method");
        Object possibleReturn = invocationContext.proceed();
        logger.info("The object the method was invoked on:" + invocationContext.getTarget().getClass().getName());

        return possibleReturn;

    }
}

Step 3: Inside service, you have to annotate with InterceptorBindinAnnotation
    @LogEvent
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
   @GET
    @LogEvent
    public String sayGreet() {
        return haigreeter.sayGreet() + " " + hellogreeter.sayGreet();
    }
..............................................................................................
..............................................................................................
                           Private keyword on Dependency field

Quarkus and its native image generation performs better CDI work without private members. Dependency injection requires a lot of Reflection API usage, which is very expensive. In the interest of generating better-performing native images, don’t use the private modifier for fields. Stick with package-level access for class-level variables.
......................................
Quarkus-Only Enhancements to CDI Quarkus enriches its implementation of CDI in ArC, by adding the following features, among others.
.............................................................................................

Assignment -3 : 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

Features:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI

New Features to be added:

1.Generate 16 digit ISBN and 32 digit ISBN code via ISBN Generator class
2.Inject ISBNGenerator ServiceBean into BookService - Which ISBN Digit you want- DI
3.Inject book authors and price as DI into BookService class
4.You have to write interceptor for BookService Bean to watch the book operations 

..............................................................................................
				MicroProfile Spec- Config
..............................................................................................

 A Quarkus application and Quarkus itself (core and extensions) are both configured via the same mechanism that leverages the SmallRye Config API an implementation of the MicroProfile Config specification.


Config Sources:
  The place from where the configuration data is present.


1.(400) System properties

2.(300) Environment variables

3.(295) .env file in the current working directory

4.(260) Quarkus Application configuration file in $PWD/config/application.properties

5.(250) Quarkus Application configuration file application.properties in classpath

6.(100) MicroProfile Config configuration file META-INF/microprofile-config.properties in classpath

7.Third Party Configuration infrastructure
  consul,kubernetes,zookeeper,git,external webserver etc.....

 A configuration property lookup starts by the "highest ordinal configuration source available and works it way down to other sources until a match is found". This means that any configuration property may override a value just by setting a different value in a higher ordinal config source. For example, a property configured using an environment property overrides the value provided using the application.properties file.

.............................................................................................
				  Property Implementation
............................................................................................
How to read properties from the application.property file:

application.properties
#This is custom property
user.name=Subramanian
user.role=admin
user.password=foo
greeting.message=Hello,Property

package org.acme.service;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {
    //inject application.property file property
    @ConfigProperty(name = "greeting.message")
    String message;

    public String sayHello() {
        return message;
    }
}
package org.acme;

import org.acme.service.GreetingService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @Inject
    GreetingService greetingService;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return greetingService.sayHello();
    }
}
What if the property is not supplied? - no property is present?

-You will get 

java.util.NoSuchElementException: SRCFG00014: The config property greeter.message is required but it could not be found in any config source
	at io.smallrye.config.SmallRyeConfig.convertValue(SmallRyeConfig.java:307)
	at io.smallrye.config.inject.ConfigProducerUtil.getValue(ConfigProducerUtil.java:81)
	at io.quarkus.arc.runtime.ConfigRecorder.validateConfigProperties(ConfigRe

Solution : 

default Value
package org.acme.service;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {
    //inject application.property file property
    @ConfigProperty(name = "greeting.message", defaultValue = "default")
    String message;

    public String sayHello() {
        return message;
    }
}
What if i have more propeties?

greeter.message=Hello,From Property
greeter.name=Subramanian
greeter.date=today

How to read properties via program without annotation?

package org.acme.service;

import org.eclipse.microprofile.config.Config;
import org.eclipse.microprofile.config.ConfigProvider;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {

    public String getUserInfo() {
        Config config = ConfigProvider.getConfig();
        // return config.getValue("myuser.name", String.class);
        return config.getOptionalValue("myuser.name", String.class).orElse("bar");
    }

}
............................................................................................
System Properties:

 System properties are supplied through -D flag during startup.

Dev Mode:

 mvn  compile quarkus:dev  -Dgreeter.message=Hello,FromSystem
 
How to test ?
 Run the application, see from where the property is coming

Keep the property in the application.property file, and see the difference.

if same property present in system and application.properties who will win ? System because it has the highest ordianal value.

 
Production Mode
 -JVM- Runnar Jar
    java -Dgreeter.message=Hello,FromSystem -jar target/quarkus-app/quarkus-run.jar

-Native Mode
    export GREETER_MESSAGE=Hello,FromSystem;   ./target/myapp-runner 

..............................................................................................
			How to read Properties from Envinonment Variables
..............................................................................................

In Unix/Linux,Mac, How to set env variables

export VariableName=value

In windows

SET VariableName=value
eg:
E:\session\IBM\2022\march\quarkus\code-with-config>SET greeting.message=Hello,From Env Variable

E:\session\IBM\2022\march\quarkus\code-with-config>mvnw compile quarkus:dev


What if i have 
.greeter.message property in application.property file
and supply via Env variable
and supply via system property 

Which property value will be displayed?
  -system property.
.............................................................................................
			     	.env file

env files isloate all env variables and group into single source of the truth

.env file in the current working directory

QUARKUS_DATASOURCE_PASSWORD=youshallnotpass 
The name QUARKUS_DATASOURCE_PASSWORD the same conversion rules used for Environment variables.
For dev mode, this file can be placed in the root of the project, but it is advised to not check it in to version control.


steps:

1.create .env file inside project root dir

config-app
src
target
.env

2.Add config information inside .env file
 -Name of the Property should be UPPERCASE_UPPERCASE=value like Env variable

.env
GREETER_MESSAGE=Hello,FromENVFILE


3.build app and run test

http://localhost:8080/hello
Subramanian Hello,FromENVFILE today
..............................................................................................
..............................................................................................
		      Can We have multiple application.properties 
............................................................................................

Yes , we can multiple application.properties files


Locations:
 
1.
src
 |
 main
  |
  resources
     application.proprties

2.App-name - config-app
   
  config
	|
     application.properties

 src
 |
 main
  |
  resources
     application.proprties

You have to run in production mode , for the first file options
public String configFolder() {
        Config config = ConfigProvider.getConfig();
        // return config.getValue("myuser.name", String.class);
        return config.getOptionalValue("myprop.value", String.class).orElse("bar");
    }

-mvn clean
-mvn package
-java -jar target/quarkus-app/quarkus-run.jar
.............................................................................................
			   .............................................................................................
		How to externalize the property injections into Separate Program
.............................................................................................

Use case:

import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @ConfigProperty(name = "firstName")
    String firstName;
    String city;
    String state;
    String lastName;

}
Grouping properties with @ConfigurationProperties

package org.acme;


import io.quarkus.arc.config.ConfigProperties;
import org.eclipse.microprofile.config.inject.ConfigProperty;
//import org.eclipse.microprofile.config.inject.ConfigProperty;

@ConfigProperties(prefix = "cust")
public class CustomerConfiguration {
    @ConfigProperty(name = "name", defaultValue = "default Customer Name")
    public String name;
}

application.properties
cust.name=foo


package org.acme;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @Inject
    CustomerConfiguration custConfig;

    @GET
    public String customerInfo() {
        //  return custConfig.firstName;
        return custConfig.name + "Hello";
    }
}
..............................................................................................

.............................................................................................

@ConfigProperties has been deprecated: dont use in latest Quarkus implementations:
...................................................................................

Use @ConfigMapping annotation on interface level

application.properties
cust.name=Subramanian

@ConfigMapping(prefix="cust")
public interface CustomerConfiguration {

   //name
    String name();

}
package org.acme;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/customer")
public class CustomerResource {

    @Inject
    CustomerConfiguration custConfig;
    @GET
    public String customerInfo() {
        return custConfig.name();
    }
}

Res:
http://localhost:8080/customer

Subramanian
.............................................................................................
How to configure default values in the @ConfigMapping annotation

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    String name();
}

There is type provided by java " java.util.Optional<T>":

Optional class helps to convert null into usefull defaults.

Java has the very problem is NullPointerException.


 eg:
    Customer customer= service.findById(10)
    log.info(customer.getCity());

   The result would be
   -Customer
       or
   -null
if there is no customer which throws null pointer exception?

How to solve this problem?

Way - 1
  if(customer!=null){ 
     log.info(customer.getCity());
  }else{

     log.info("customer not found")
  }

Way -2

     String city = service.findById(10).orElse("Default City")

..........................................................................................
application.properties
#cust.name=Subramanian

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    Optional<String> name();
}

@GET
 public String customerInfo() {
        return custConfig.name().orElse("default Name");
   }
}
.............................................................................................

.............................................................................................
				   Nested properties

application.properties
cust.address.city=coimbatore

@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    Optional<String> name();
    Address address();
    //inner type
    interface Address {
        Optional<String> city();
    }
}
    public String customerInfo() {
        String city = custConfig.address().city().orElse("coimbatore");
        return custConfig.name().orElse("default Name") + " " + city;
    }
}
.............................................................................................
Programmetic access

SmallRyeConfig config = ConfigProvider.getConfig.unWrap(SmallRyeConfig.class);
CustomerConfiguration cust=config.getConfigMapping(CustomerConfiguration.class);
............................................................................................

What if application.properties key name is different from programmetic name

application.properties
cust.firstName=Subramanian


@ConfigMapping(prefix = "cust")
public interface CustomerConfiguration {
    @WithName("firstName")
    Optional<String> name();
    Address address();
    //inner type
    interface Address {
        Optional<String> city();
    }
}
..............................................................................................
					Profiles
.............................................................................................

Profiles:
  The environment where the application is running

1.dev
2.test
3.prod

Profile in the the property name:

%{profile-name}.config.name

Profile Names in Qurakus:

dev - development
prod - production profile
test -  test profile

profile specification configuration:

application.properties

%dev.message.greet=messagefrom dev
%prod.message.greet=messagefromprod

.env file
_{PROFILE}_CONFIG_KEY=VALUE

_DEV_MESSAGE_GREET=VALUE

eg:

1.application.properties
%dev.greeter.message=Hello,From Property Development
%prod.greeter.message=Hello,From Property Production


profile aware files

application-profile.properties

application-dev.properties
application-prod.properties

eg:

Steps:
1.Add application-prod.properties inside src/main/resources folder
greeter.message=Hello,From Property Production&&&

2.run in dev mode and test it

3.run in production mode and test it.
..............................................................................................
..............................................................................................
						YAML
..............................................................................................
YAML Getting started:
https://www.redhat.com/en/topics/automation/what-is-yaml


How to enable yaml configurations?

quarkus ext add config-yaml

<dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-config-yaml</artifactId>
</dependency>

old properties- application.properties
%dev.greeter.message=Hello,From Property Development!!!
#%prod.greeter.message=Hello,From Property Production
greeter.name=Subramanian
greeter.date=today
myuser.name=Subramanian
cust.firstName=Subramanian
cust.address.city=Chennai

application.yaml
##This is custom property
#myuser.name=Subramanian
#user.role=admin
#user.password=foo
#greeting.message=Hello,Property File
##greeting.message=12
##Customer property
#customer.id=1
#customer.name=Subramaian
##customer.city=coimbatore
#
##Profile specific properties
#%dev.message.greet=Dev Message
##%prod.message.greet=Production Message

"%prod":
  message:
    greet: The Message From Production Yaml

"%dev":
  message:
    greet: The Message From Development Yaml
"%test":
  greeter:
    message: The message From Test
greeter:
  name: Subramanian
  message: Hello,From YAML
  date: Today
myuser:
  name: Myuser
cust:
  firstName: Subramanian
  address:
    city: Delhi
..............................................................................................
..............................................................................................
				Quarkus built in properties


Quarkus properties begin with "qurakus.modulename.property"


"%prod":
  greeter:
    message: The Message From Production
  quarkus:
    http:
      port: 3001

"%dev":
  greeter:
    message: The Message From Development
    # Update existing quarkus related properties
    quarkus:
      http:
        port: 3000

"%test":
  greeter:
    message: The message From Test
greeter:
  name: Subramanian
  message: Hello,From YAML
  date: Today
myuser:
  name: Myuser
cust:
  firstName: Subramanian
  address:
    city: Delhi

Yaml files:

application.yaml
application-prod.yaml
config/application.yaml
..............................................................................................
Assignment -4 : 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

Features:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI

->Generate 16 digit ISBN and 32 digit ISBN code via ISBN Generator class
->Inject ISBNGenerator ServiceBean into BookService - Which ISBN Digit you want- DI
->Inject book authors and price as DI into BookService class
->You have to write interceptor for BookService Bean to watch the book operations 

New features:
 -Add Configuration data for some book, read from the configuration source
 -Profile based config
 -properties
 -Yaml
 -@config vs @configMapping

...........................................................................................
				  Consul: Reading Properties
.............................................................................................

Requirement:

1.Your application
2.Consul Server - You need to run consul server separtly.


Project Setup:

quarkus ext add config-consul

 <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-config-consul</artifactId>
  </dependency>

Steps:

1.start consul server.

-Via Docker
open cmd prompt and run this

docker run --rm --name consul -p 8500:8500 -p 8501:8501 consul:1.7 agent -dev -ui -client=0.0.0.0 -bind=0.0.0.0 --https-port=8501

1.Have simple config property, return the value

package org.acme;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @ConfigProperty(name = "greeting.message", defaultValue = "Hello RESTEasy")
    String message;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return message;
    }
}

Getting Property from consul server:

Steps:

1.start consul server.

-Via Docker
open cmd prompt and run this

$ docker run --rm --name consul -p 8500:8500 -p 8501:8501 consul:1.7 agent -dev -ui -client=0.0.0.0 -bind=0.0.0.0 --https-port=8501

2.browse consul page.
  http://localhost:8500/ui/dc1/kv/create
As of now , dont enter any thing.

3.You have to connect application with consul server, for that you need to configure via application.properties or application.yaml


application.properties

#greeting.message=Hello,application.properties
#application name: We have to use this name as the application name that was
# configured when standing up the config server
quarkus.application.name=consul-app
#enable retrieval of configuration from the consule -this is by default is disabled
quarkus.consul-config.enabled=true
#Key in Consul's KV store that the Quarkus application will read and try to extract properties from
quarkus.consul-config.properties-value-keys=config/${quarkus.application.name}
.............................................................................................
  		     Quarkus - Database Integration
..............................................................................................
			        Quarkus-ORM
			   JPA,Hibernate,Panache
..............................................................................................
What is JPA?
  JPA is JEE Standard to build object relational mapping technologies.

History of ORM:

-ORM Technology introduced in EJB 
   Entity Bean
Because of drawback of Entity Beans,The developer who created a framework based ejb entity bean called "Hibernate"


How Hibernate works?

Object ----is mapped in xml-->loaded into hibernateEngine---Will start all persistency.


Object is mapped via annotations--loaded into hibernateEngine---Will start persistency

				   App Java Apps
					|
				     Objects
					|
				    xml or Annotation
					|
				   Hibernate Engine(Will translate SQL QUERES)
					 |
				     DataSource
				          |
				    JDBC Driver


Once ORM Technologies started becoming popular JCP, started standarzing ORM, who relased spec
"JPA"

What is JPA?
  STANDARD can be used by developer who can use any persistency implementation-Hibernate,X,Y..


				    ORM APPS
					|
				       JPA 
				-----------------------
			        |        |     |      
			   Hibernate  IBatis  Toplink
..............................................................................................
				Quarkus and JPA

Quarkus provides two abstraction on JPA

1.JPA - Hibernate
					APP
					 |
					JPA
					 |
				      Hibernate

2.JPA - Panche - Hibernate

					 APP
					  |
					 JPA
					  |
					PANCHE
					  |
				       HIBERNATE


............................................................................................

Data Source Configuration:

quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:mem:default
quarkus.datasource.jdbc.max-size=13

quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:mem:users
quarkus.datasource.users.jdbc.max-size=11

quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12

quarkus.datasource.customers.db-kind=postgresql 
quarkus.datasource.customers.username=<your username>
quarkus.datasource.customers.password=<your password>
quarkus.datasource.customers.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.customers.jdbc.max-size=16

Microservice design pattern called "Database Per Service" Pattern , according to that pattern
Quarkus implments datasource configuration

 quarkus.datasource."ServiceName".dsproperties=value


DbKind: Type of database
common db-kind value conventions

DB2: db2

Derby: derby

H2: h2

MariaDB: mariadb

Microsoft SQL Server: mssql

MySQL: mysql

Oracle: oracle

PostgreSQL: postgresql, pgsql or pg

JDBC datasource
...............
Quarkus team who have built connection pool lib 

  "Agroal" library allows the definition of java.sql.DataSource with connection pooling.

quarkus ext add agroal

Ex:
application.properties
#Datasource configuration
quarkus.datasource.db-kind=h2
#Microservice Service Per Database - Customer Service
quarkus.datasource.customers.db-kind=h2


Resources:
package org.acme.user;

import org.acme.service.CustomerJdbcService;
import org.acme.service.UserJDBCService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/customers")
public class CustomerResource {

    @Inject
    CustomerJdbcService customerJdbcService;

    @GET
    public Response getUsers() {
        return Response.ok().entity(customerJdbcService.listCustomers()).build();
    }
}

package org.acme.user;

import org.acme.service.UserJDBCService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/users")
public class UserResource {

    @Inject
    UserJDBCService userJDBCService;

    @GET
    public Response getUsers() {
        return Response.ok().entity(userJDBCService.listUsers()).build();
    }
}

JDBC lAYER:
package org.acme.service;

import io.agroal.api.AgroalDataSource;
import io.quarkus.agroal.DataSource;
import org.acme.service.enity.User;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

@ApplicationScoped
public class CustomerJdbcService {

    //inject datasource according to service
    @Inject
    @DataSource("customers")
    AgroalDataSource defaultDataSource;

    List<User> customers = new ArrayList<>();

    @PostConstruct
    public void init() {
        System.out.println("H2- db init is called");
        try {
            Connection connection = defaultDataSource.getConnection();
            System.out.println(connection);
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("CREATE TABLE customer(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO customer " + "VALUES (101, 'Dhivya Sree')");
            stmt.executeUpdate("INSERT INTO customer " + "VALUES (102, 'Srisha')");
            stmt.executeUpdate("INSERT INTO customer " + "VALUES (103, 'Geetha Subramanian')");

            ResultSet rs = stmt.executeQuery("select * from customer");
            while (rs.next()) {
                customers.add(new User(rs.getInt(1), rs.getString(2)));
            }
            stmt.close();
            connection.close();

        } catch (SQLException sqlException) {
            System.out.println(sqlException.getMessage());
        }
    }

    public List<User> listCustomers() {
        return customers;
    }


}
package org.acme.service;

import io.agroal.api.AgroalDataSource;
import org.acme.service.enity.User;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;


@ApplicationScoped
public class UserJDBCService {

    @Inject
    AgroalDataSource defaultDataSource;
    List<User> users = new ArrayList<>();

    @PostConstruct
    public void init() {
        System.out.println("H2- db init is called");
        try {
            Connection connection = defaultDataSource.getConnection();
            System.out.println(connection);
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("CREATE TABLE user(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO user " + "VALUES (101, 'Subramanian')");
            stmt.executeUpdate("INSERT INTO user " + "VALUES (102, 'Ram')");
            stmt.executeUpdate("INSERT INTO user " + "VALUES (103, 'Karthik')");

            ResultSet rs = stmt.executeQuery("select * from user");
            while (rs.next()) {
                //System.out.println(rs.getInt(1) + "  " + rs.getString(2));
                users.add(new User(rs.getInt(1), rs.getString(2)));
            }
            stmt.close();
            connection.close();

        } catch (SQLException sqlException) {
            System.out.println(sqlException.getMessage());
        }
    }

    public List<User> listUsers() {
        return users;
    }
}
..............................................................................................
				ORM Integration -  JPA-Hibernate
..............................................................................................

Dependency:

Driver:
 H2
quarkus ext add jdbc-h2

Hibernate-ORM
quarkus ext add hibernate-orm


application.properties
# datasource configuration
quarkus.datasource.db-kind = h2
quarkus.datasource.username = hibernate
quarkus.datasource.password = hibernate
quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/hibernate_db

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation=drop-and-create

Hibernate Features:

 -CURD operations
 -Caching - You can use hibernate in memory caching, caching providers  (memcache,redis,inifispan)
 -Transaction Management -JTA -narayana-jta ---| Reactive + Non Reactive Style


Steps:
1.Enity

package org.acme.service.enity;
import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name = "events")
public class Event {
    @Id
    @SequenceGenerator(name = "eventseq", sequenceName = "event_id_seq", allocationSize = 1, initialValue = 1)
    @GeneratedValue(generator = "eventseq")
    private int eventId;
    @Column(name = "event_title")
    private String title;
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "event_date")
    private Date eventDate;

    public Event() {
    }

    public Event(String title, Date eventDate) {
        this.title = title;
        this.eventDate = eventDate;
    }

    public int getEventId() {
        return eventId;
    }

    public void setEventId(int eventId) {
        this.eventId = eventId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Date getEventDate() {
        return eventDate;
    }

    public void setEventDate(Date eventDate) {
        this.eventDate = eventDate;
    }
}

2.Service Layer
package org.acme.service;

import org.acme.service.enity.Event;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.transaction.Transactional;
import java.util.Date;
import java.util.List;

@ApplicationScoped
public class EventHibernateService {

    @Inject
    EntityManager entityManager;

    public List<Event> findAll() {
        //JPQL - Java Persistency Query Language
        return entityManager.createQuery("SELECT e FROM Event e", Event.class).getResultList();
    }
    @Transactional
    public void createEvent() {
        Event event = new Event("Our very first event!", new Date());
        //entityManager.getTransaction().begin();
        entityManager.persist(event);
        //entityManager.getTransaction().commit();
    }
}
Resource:
package org.acme.event;


import org.acme.service.EventHibernateService;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/api/events")
public class EventResource {

    @Inject
    EventHibernateService eventService;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response listEvents() {
        return Response.ok(eventService.findAll()).build();
    }

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response createEvent() {
        eventService.createEvent();
        return Response.status(201).entity("Event Created").build();
    }
}
..............................................................................................
			    JPA-Panche-Hibernate
..............................................................................................
Panche is a framework built by Red hat for quarkus which is similar to "Spring CURD Repostories"

In General, curd is implemented using

JPA and Hibernate specific apis, this is makes our code tightly coupled.

DAO Design pattern abstracts away how to handle database operations like DOMAIN Models.

Quarkus offers that abstraction via panache.

Steps:
quarkus ext add hibernate-orm-panache


Panche Entities:

@Entity
public class Event extends PancheEntity {

}

-It becomes entity and also apis to manipulate Entity

Panche PRogramming can be written using two design patterns

1.Active Record pattern
2.DAO Pattern or Repository Pattern


Panche Entity Rules

1.variables are declared using public keyword with no setters and getters

2.id property , identifier logic not necessary by default.

3.State and behaviour in the same class
   public String name; -state
   findByName()-behaviour   
4.Simplied query operations
    using JPQL but simplified syntax

@Entity
public class Event extends PancheEntity {

}

if you want to customize id generation 
@Entity
public class Event extends PancheEntityBase {

}
.........................................................................................
1.Active Record pattern:
  You can use entity instance directly into Service/Resources

 Event.findAll()
 Event.findById(id)
 Event.persist()
 Event.delete()
 Event.update()

eg:


package org.acme.repository;

public enum Status {
    Alive,
    Deceased
}

package org.acme.repository;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

import javax.persistence.Entity;
import java.time.LocalDate;
import java.util.List;


//Looks like Repository layer
@Entity
public class Person extends PanacheEntity {
    //fields ;must be declared using public access modifer
    //id field need not be given because it is already declared in the base class
    public String name;
    public LocalDate birth;
    public Status status;

    //extra methods
    public static Person findByName(String name) {
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive() {
        return list("status", Status.Alive);
    }

    public static void deleteStefs() {
        delete("name", "Stef");
    }
}

package org.acme.panche.resource;

import org.acme.service.PersonService;

import javax.inject.Inject;
import javax.transaction.Transactional;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/person")
public class PersonResource {

    @Inject
    PersonService personService;

    @GET
    public Response findAll() {
        // return Response.ok().entity(Person.listAll()).build();
        return Response.ok().entity(personService.findAll()).build();
    }

    @POST
    @Path("/create")
    public Response createPerson() {
        return Response.ok(personService.createPerson()).build();
    }
}
package org.acme.service;

import org.acme.repository.Person;
import org.acme.repository.Status;

import javax.enterprise.context.ApplicationScoped;
import javax.transaction.Transactional;
import java.time.LocalDate;
import java.time.Month;
import java.util.List;

@ApplicationScoped
public class PersonService {

    public List<Person> findAll() {
        return Person.listAll();
    }

    @Transactional
    public String createPerson() {
        Person person = new Person();
        person.name = "Subramanian";
        person.birth = LocalDate.of(1981, Month.APRIL, 10);
        person.status = Status.Alive;
        //save into db
        Person.persist(person);
        return "Created";
    }
}

2.DAO Pattern or Repository Pattern

-Create Entity separatly : follow all jpa entity rules

@Enity
public class Event {
  private int id;
  private String title
  //setters and getters
}

-Create Repository class
 @ApplicationScoped
 public class EventRepository implements PanacheRepository<Event> {
  
 }

EG:
Entity:
package org.acme.service.enity;
import javax.persistence.*;
import java.util.Date;

@Entity
@Table(name = "events")
public class Event {
    @Id
    @SequenceGenerator(name = "eventseq", sequenceName = "event_id_seq", allocationSize = 1, initialValue = 1)
    @GeneratedValue(generator = "eventseq")
    private int eventId;
    @Column(name = "event_title")
    private String title;
    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "event_date")
    private Date eventDate;

    public Event() {
    }

    public Event(String title, Date eventDate) {
        this.title = title;
        this.eventDate = eventDate;
    }

    public int getEventId() {
        return eventId;
    }

    public void setEventId(int eventId) {
        this.eventId = eventId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Date getEventDate() {
        return eventDate;
    }

    public void setEventDate(Date eventDate) {
        this.eventDate = eventDate;
    }
}

Reposistry:
package org.acme.repository;

import io.quarkus.hibernate.orm.panache.PanacheRepository;
import org.acme.service.enity.Event;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class EventPancheRepository implements PanacheRepository<Event> {
    
}

Resource:
package org.acme.event;

import org.acme.repository.EventPancheRepository;
import org.acme.service.enity.Event;

import javax.inject.Inject;
import javax.transaction.Transactional;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;
import java.util.Date;

@Path("/api/event/panche")
public class EventPancheResource {

    @Inject
    EventPancheRepository repository;

    @GET
    public Response getEvents() {
        return Response.ok().entity(repository.listAll()).build();
    }

    @POST
    @Transactional
    public Response createEvent() {
        Event event = new Event();
        event.setTitle("Learn Quarkus with Panche");
        event.setEventDate(new Date());
        repository.persist(event);
        return Response.ok().entity(repository.listAll()).build();
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
			Complete CURD using Panche

package org.acme.entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Table;
import java.util.Date;

@Entity
@Table(name = "events")
public class Event extends PanacheEntity {
    @Column(name = "event_title")
    public String title;
    @Column(name = "event_date")
    public Date eventDate;

    //custom api
    public static Event findByTitle(String title) {
        return find("title", title).firstResult();
    }
}
............................................................................................
package org.acme;

import org.acme.entity.Event;
import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.transaction.Transactional;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
import java.net.URI;
import java.util.Date;
import java.util.List;

@Path("/events")
@Produces(MediaType.APPLICATION_JSON)
public class EventResource {

    @GET
    public List<Event> list() {
        return Event.listAll();
    }

    @GET
    @Path("/{id}")
    public Event get(@PathParam("id") Long id) {
        Event event = Event.findById(id);
        if (event == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        return event;
    }

    @GET
    @Path("/search/{name}")
    public Event search(@PathParam("name") String name) {
        Event event = Event.findByTitle(name);
        if (event == null) {
            throw new WebApplicationException("Event with Name of " + name + " Not Found");
        }
        return event;
    }

    @GET
    @Path("/count")
    public Response countEvents(@PathParam("name") String name) {
        return Response.ok(Event.count()).build();
    }

    @DELETE
    @Path("/{id}")
    @Transactional
    public void removeEvent(@PathParam("id") Long id) {
        Event event = Event.findById(id);
        if (event == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        event.delete();
    }

    @PUT
    @Path("/{id}")
    @Transactional
    public Response updateEvent(@PathParam("id") Long id, Event event) {
        Event foundEvent = Event.findById(id);
        if (foundEvent == null) {
            throw new WebApplicationException("Event with Id of " + id + " Not Found");
        }
        //update
        foundEvent.title = event.title;
        return Response.ok(foundEvent.id + foundEvent.title + "has been modified").build();
    }

    @POST
    @Transactional
    public Response createEvent(Event event) {
        event.eventDate = new Date();
        event.persist();
        return Response.created(URI.create("/events/" + event.id)).build();
    }

    //inner class
    @Provider
    public class ErrorMapper implements ExceptionMapper<Exception> {
        @Override
        public Response toResponse(Exception exception) {
            return Response.status(500).entity(exception.getMessage()).build();
        }
    }
}
..............................................................................................

Assignment - 5 : 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

Features:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI

->Generate 16 digit ISBN and 32 digit ISBN code via ISBN Generator class
->Inject ISBNGenerator ServiceBean into BookService - Which ISBN Digit you want- DI
->Inject book authors and price as DI into BookService class
->You have to write interceptor for BookService Bean to watch the book operations 
->Add Configuration data for some book, read from the configuration source
 -Profile based config
 -properties
 -Yaml
 -@config vs @configMapping

New Features:

 Convert your Book inmemory into  database
 Implementation:
   JPA-Hibernate-Panche
    ->USING Active Record Pattern
    ->Using DAO/Repository Pattern
  Try both Patterns , see the differences.
..............................................................................................
				Micro Service Communication Patterns
..............................................................................................
Micro Service:
 It is an architectural  style to build distributed apps.
Monolith Model
 It is also architectural style to build distributed apps.

Micro service Patterns:
 loosly coupled app.
The big application is broken into smaller units,Each unit is called service.

Service is nothing but program which represents domain in biz.eg inventory,purchase,order...

Services are also called as "APIs".

What are different ways to represent services /api?

A.WebServices
1.SOAP Service
2.REST Service

RESTFull Service or Rest api is most popular pattern - Quarkus - RestEasy.

2.GraphQL service

3.RPC Service - Remote Procedural Call
   gRPC framework


Service communications:

Service to Service , service could be any type.

REST to RPC
RPC to REST

REST To REST 

Service Communication need two things

1.transport layer - HTTP or TCP or http 2, or any protocal supported by services

2.data format  -  json or xml or binary or text etc....


..............................................................................................
				1.REST Style Communication in Quarkus
..............................................................................................

REST TO REST In Quarkus
1.MicroProfile  rest client
2.Vertx Web Client Api 
3.Java 11 HTTP Client api

MicroProfile Rest Client:
The MicroProfile Rest Client provides a "type-safe approach" to invoke RESTful services over HTTP.
As much as possible the MP Rest Client attempts to use Jakarta RESTful Web Services 2.1 APIs for consistency and easier re-use.

SmallRye RestClient is the reference implementation to talk to REST API over http.

Quarkus uses this implementation to achive Service communication.
.................................................................


Steps:

1.declare model class to represent REST response type.

package org.acme.models;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

//mapper class for incoming response
@JsonIgnoreProperties(ignoreUnknown = true)
public class Country {
    public String name;
    public String capital;
    public List<Currency> currencies;
    public static class Currency {
        public String code;
        public String name;
        public String symbol;
    }
}

2.Proxy Class Implementation
Proxy class is bridge class between two services.
Takes care of serizlation and deserizalation , marshalling,demarshalling
MicroProfile Rest Client takes generating proxy classes on fly. we need to provide high level information via interface.


Interface which exposes apis which communicates remote services

package org.acme.rest.client;

import org.acme.models.Country;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import java.util.Set;

@RegisterRestClient
@Path("/v3.1")
public interface CountryService {
    //api to invoke third party
    @Path("/name/{name}")
    @GET
    Set<Country> getByName(@PathParam("name") String name);
}

3.Configuring in application.properties

Syntax
serviceName/mp-rest/url=url
serviceName/mp-rest/scope=javax.inject.SingleTon

org.acme.rest.client.CountryService/mp-rest/url=https://restcountries.com
org.acme.rest.client.CountryService/mp-rest/scope=javax.inject.Singleton

4.Dependency Injection.
package org.acme;

import org.acme.models.Country;
import org.acme.rest.client.CountryService;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.jboss.resteasy.annotations.jaxrs.PathParam;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.util.Set;

@Path("/country")
public class CountryResource {

    @Inject
    @RestClient
    CountryService countryService;

    @GET
    @Path("/name/{name}")
    public Set<Country> findByCountry(@PathParam("name") String name) {
        return countryService.getByName(name);
    }

}

http://localhost:8080/country/name/oman

[
{
capital: [
"Muscat"
]
}
]

Code Refactoring:

if we want to simplifiy in the application.properties with respect to Service Name

application.properties
org.acme.rest.client.CountryService/mp-rest/url=https://restcountries.com
org.acme.rest.client.CountryService/mp-rest/scope=javax.inject.Singleton

refactored configuration
country-api/mp-rest/url=https://restcountries.com
country-api/mp-rest/scope=javax.inject.Singleton

@Path("/v3.1")
@RegisterRestClient(configKey = "country-api")
public interface CountryService {
    //api to invoke third party
    @Path("/name/{name}")
    @GET
    Set<Country> getByName(@PathParam("name") String name);
}
.............................................................................................

Assignment - 6.

Already you have BookService app.
 change bookservice port from 8080 - 3000

http://localhost:3000/api/books
  /list
  /save
  /edit
  /delete

Req:
 You have to build new app called PublisherService App.
 Port : 3001.

You have to write service which should consume BookService  via RestClient Spec

Url pattern
 localhost:3001/api/publisher/book/list   - 
 localhost:3001/api/publisher/book/create -
..............................................................................................
				Reactive Programming
..............................................................................................

What is Reactive?
 Response oriented Programming /event driven programming.

Why Reactive Programming?
  Reactive Programming provides reliable distributed system.

Common characteristics of Microservice Distributed System
https://www.reactivemanifesto.org/

1.Responsive
   The System should respond in a timely manner - on Time

2.Reslient
   Any distributed System subject to fail.
  if failures, we need to handle properly- this is called fault/failure/reslient Management.
3.Elastic 
    if more work load, the system should be expaneded automatically and if there is no load     system should decrease the resources
4.Message driven
   The system components(services) should communicate each other via messages without blocking each other- Non blocking.

How to build reactive system?

Using ReactiveX specification.
   
   ReactiveX is lib or framwork written any lanugage, helps to build declarative data oriented/message oriented applications.

Where is reactive is used?

  Where service communication is there or where data is moved among programs
.............................................................................................
				 Data Is every thing
..............................................................................................

In distribtued systems , data is moved from one program to another program.

Traditional Data transfer:

Let us take two java class
package com.ibm.traditional;

import java.util.List;

public class OrderService {
    public List<Order> findAll() {
        return List.of(new Order(1, "Books"), new Order(2, "Phone"));
    }
}


package com.ibm.traditional;

import java.util.List;

public class CustomerService {
    private OrderService orderService;

    public CustomerService() {
    }

    public CustomerService(OrderService orderService) {
        this.orderService = orderService;
    }

    public OrderService getOrderService() {
        return orderService;
    }

    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }

    public List<Order> getAllOrders() {
        return this.orderService.findAll();
    }
}
package com.ibm.traditional;

public class Order {
    private int orderId;
    private String productName;

    public int getOrderId() {
        return orderId;
    }

    @Override
    public String toString() {
        return "Order{" +
                "orderId=" + orderId +
                ", productName='" + productName + '\'' +
                '}';
    }

    public void setOrderId(int orderId) {
        this.orderId = orderId;
    }

    public String getProductName() {
        return productName;
    }

    public void setProductName(String productName) {
        this.productName = productName;
    }

    public Order(int orderId, String productName) {
        this.orderId = orderId;
        this.productName = productName;
    }
}


package com.ibm.traditional;

public class App {
    public static void main(String[] args) {
        CustomerService customerService = new CustomerService(new OrderService());
        System.out.println(customerService.getAllOrders());
    }
}

Features:

Actors:
1.provider  -OrderService
2.Consumer  -CustomerService

1.CustomerService is pulling data from the OrderService
 ->Customer always controls Orderservice, customer always ask data.
 ->Tight coupling between services
 ->Data is reterived one shot,which degrades performance when more data is reterived.
 ->if you want to process the data like sql quieries, inside application is difficult 
   eg: i want only orders which are in stock.

  "PULL Based Program"

2.Reactive Way of getting and processing data - Push Based Programming

  ->CustomerService will not able to control data reterival , Where Customer Service is waiting for data
   
   ->OrderService(Publisher/Producer/Provider) will push the data to CustomerService (Consumer/Subscriber/Listener).


   OrderService---->push data ---------->CustomerService
..............................................................................................
			    PUSH Based Programming


Producer need to push data where Consumer need to listen data - this forms a arch called "Event Driven Programming". 
    It is implemented via design pattern called "Observable Design Pattern"

Observable Desing pattern enables "streaming model" - Stream is nothing but flow of data in sequence.

We can observe the stream, meaning that we can apply stream processing -  filtering,transformation,coimbining.
  Streaming processing need to be done using apis.

How to write api?
   Usin functional programming principles, like declarative,immutable and pure functions 
in reactive programming apis are called operators.
............................................................................................

Reactive Programming = {Observable Design pattern + functional Programming Principles + Iterator Design Pattern(reading) }
............................................................................................
				How to build Reactive Programming
.............................................................................................

Reactive Programming is language independent.
https://reactivex.io/intro.html

Reactive Programming in java:

Reactive Programming in java is based on spec called "reactive Stream spec"
  https://www.reactive-streams.org/

There are many libs

1.rxjava - Netflix
2.projectreactor - VMWare
3.Mutiny - RedHat /SmallRye Project


Quarkus uses Mutiny as Reactive Wrapper.


Actors:
1.Publisher
2.Consumer

Mutiny Publisher

1.Uni
    Publisher can emit 0..1 element only
2.Multi
   Publisher can emit 0...N elements


Any object can emit event(data +signal)

Events
 -data event
 -error event
 -complete event

What is Uni and Multi?
 Both are objects can emit event.

Uni can emit only one event either data,error,or comple
 0 to 1

Multi 
  Can emit sequence of more events
 0 to N events.

Where can i use mutiny?
 Mutiny has integreated with quarkus- quarkus-mutiny extension, mutiny has integrated with vertx.

Subscriber:
  Object has  listener for listening data.


package com.ibm.reactive;

public class App {
    public static void main(String[] args) {
        CustomerService customerService = new CustomerService(new OrderService());
        System.out.println(customerService.getAllOrders());
        customerService.processOrderStream();
        customerService.processSequenceStream();
    }
}
package com.ibm.reactive;

import java.util.List;

public class CustomerService {
    private OrderService orderService;

    public CustomerService() {
    }

    public CustomerService(OrderService orderService) {
        this.orderService = orderService;
    }

    public OrderService getOrderService() {
        return orderService;
    }

    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }

    public List<Order> getAllOrders() {
        return this.orderService.findAll();
    }

    public void processOrderStream() {
        //subscriber / listner
        orderService.streamOrder().subscribe().with(orders -> {
            System.out.println(orders);
        });
    }

    public void processSequenceStream() {
        orderService.streamSequence().subscribe().with(order -> {
            System.out.println(order);

        });
    }
}
package com.ibm.reactive;

import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;

import java.util.List;

public class OrderService {
    //traditional pull api
    public List<Order> findAll() {
        return List.of(new Order(1, "Books", true), new Order(2, "Phone", false));
    }

    //reactive push api
    //publisher
    public Uni<List<Order>> streamOrder() {
        //return stream.
        List<Order> orderList = List.of(new Order(1, "Books", true), new Order(2, "Phone", false));
        return Uni.createFrom().item(orderList);
    }

    public Multi<Order> streamSequence() {
        //return stream.
        return Multi.createFrom().
                items(new Order(1, "Books", true), new Order(2, "Phone", false))
                .filter(order -> order.isInStock());
    }

}





 





















  


























   
















  

















