What is Quarkus?
  Quarkus is a framework to built on the top of Various java and JEE Standards.

What is JCP ?
 Java Community Process is non profitable organization whoes responsability is to standardize the java technology (java echo system).

if any java new version comes,JCP committe need to approve.

JSR-Java Specifcation Request.

Every JSR has unique no - JSR-223

What JEP (JDK Enhancement Proposal)
     The JDK Enhancement Proposal (or JEP) is a process drafted by Oracle Corporation for collecting proposals for enhancements to the Java Development Kit and OpenJDK.


Java Technology Classification

1.JSE
2.JEE
3.JME

1.JSE - Java Standard Edition
  -Java language Spec
  -Java VM Spec


2.JEE - Java Enterise Edition
 The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.

 -Application Development Specs
    JPA Spec  - Vendor netural ORM Solutions
    JSON Binding - JSON-B  
    Java Servlet 
    JAX-RS - Building Resfull API
    JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
    JTA  - Java Transaction API
 -Container Specs 
    How to create Enterprise grade applications

3.JME - Java Micro Edition
   For building Device Apps , Mobile Development.

Why JEE Spec failed In Modern Computing?

     JEE Spec was developed to build traditional "Monolothic distributed,transactional, secure Applications"


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

What if i want to build standard based microservices based On JEE?

                       "MicroProfile Specfication"



Birth of Project called MicroProfile

MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise "java microservices"

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....
..............................................................................................

Quarkus itself who does not implement Microprofile specification directly.
...............................................................................................
What is Quarkus?

 Quarkus is framwork built for building modern cloud and container native microservice,serverless architecture.

Quarkus Features:

1.Implements MicroProfile specification via smallRye project
2.Quarkus implements Reactive Stack via smallRye Muntiny
3.Quarkus implements non blocking architecture via Vert.x Engine
4.Quarkus supports Kubernets,docker ready images
5.Quarkus supports native apps via GraalVM
     -Mandrel: A specialized distribution of GraalVM for Quarkus
6.Quarkus supports hot reloading

Quarkus is collection many projects - modules

Modules:
1.core
2.web
3.data
4.messaging
5.reactive
6.cdi
etc...
.............................................................................................
				How to setup projects
............................................................................................

how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ

Project Creations:

1.via Quarkus cli tool
2.via Maven
   2.1.via command line
   2.2.via https://code.quarkus.io/


Setup cli tool:
https://quarkus.io/get-started

Step : 1 : install jbang build tool via windows powershell with admin access

iex "& { $(iwr https://ps.jbang.dev) } app install --fresh --force quarkus@quarkusio"
[jbang] https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/2.7.5.Final/quarkus-cli-2.7.5.Final-runner.jar is not from a trusted source thus not running it automatically.

If you trust the url to be safe to run you can do one of the following

(1) Trust once: Add no trust, just download this time (can be run multiple times while cached)
(2) Trust limited url in future: https://repo1.maven.org/maven2/io/quarkus/quarkus-cli/
(0) Cancel

[jbang] Type in your choice and hit enter. Will automatically select option (0) after 30 seconds.
1

[
Note : after installing , please close the shell/command prompt and relanuch

Step 2: Test quarkus working or not
 quarkus --help

Usage: quarkus [-ehv] [--verbose] [-D=<String=String>]... [COMMAND]
Options:
  -h, --help            Display this help message.
  -v, --version         Print version information and exit.
  -e, --errors          Display error messages.
      --verbose         Verbose mode.
  -D=<String=String>    Java properties

Commands:
  create                  Create a new project.
    app                   Create a Quarkus application project.
    cli                   Create a Quarkus command-line project.
    extension             Create a Quarkus extension project
  build                   Build the current project.
  dev                     Run the current project in dev (live coding) mode.
  extension, ext          Configure extensions of an existing project.
    list, ls              List platforms and extensions.
    categories, cat       List extension categories.
    add                   Add extension(s) to this project.
    remove, rm            Remove extension(s) from this project.
  registry                Configure Quarkus registry client
    list                  List enabled Quarkus registries
    add                   Add a Quarkus extension registry
    remove                Remove a Quarkus extension registry
  version                 Display version information.
  completion              bash/zsh completion:  source <(quarkus completion)


Step : 2: create quarkus app via Jbang tool

Open Normal Command Prompt:

quarkus create && cd code-with-quarkus


Step 3: lanuch in IDE -  Intellj Idea or vs code
 

Step 4: compile and lanuch in dev mode. using mvn

 ./mvnw compile quarkus:dev - linux/mac users

  mvnw compile quarkus:dev 
  or
  mvn  compile quarkus:dev
.............................................................................................
			MicroServices - Service Design -REST API Development
.............................................................................................
Quarkus is based on JEE Specfications and Micro Profile Specification.

1.JAX-RS
  It is spec from JEE 

Since JAX-RS is spec we need implementation.

1.RestEasy
2.Jersy

RestEasy:
  It is implemenation of JAX-RS specfication , used in side quarkus.

Quarkus has enchanced RestEasy for compatiable for native development

quarkus-resteasy
..............................................................................................

JAX-RS Terms:

1.Resource
   It represents domain model.

ProductResource
UserResource
CustomerResource

Declare Resource class annotate with @Path -  root path

API :
 HTTP Verbs(GET,POST,DELETE,PUT) - URL mapping.
...........................................................................................
package com.ibm.rs;

import javax.ws.rs.*;

@Path("/api/products")
public class ProductResource {
    //methods
    @Path("/list")
    @GET
    public String findAl() {
        return "FindAll Products!!!!!";
    }

    @POST
    @Path("/create")
    public String create() {
        return "Created...!!!!";
    }

    @PUT
    @Path("/update")
    public String update() {
        return "updated";
    }

    @Path("/remove")
    @DELETE
    public String remove() {
        return "Deleted";
    }
}

Task:
 Test the hot reloading feature is working or not.
 Test all endpoints are working or not.

............................................................................................

What is extension?

  extension is, project dependency - jar dependency.

By default , you can have extensions when create new project.

Think of Quarkus extensions as your project dependencies.

Extensions configure, boot and integrate a framework or technology into your Quarkus application. 

They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively.

How to manage extensions(dependency)?

managment means - add,removing,listing extensions

there are two ways

1.via maven or gradle 
2.via cli - quarkus

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext ls
Current Quarkus extensions installed:

? ArtifactId                                         Extension Name
? quarkus-resteasy                                   RESTEasy JAX-RS
? quarkus-resteasy-jackson                           RESTEasy Jackson


E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext rm resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been uninstalled

How to send JSON Payload as Response?

Quarks cant convert any object into JSON by default with help of "RestEasy" extension

Add resteasy-jackson

E:\session\IBM\2022\march\quarkus\code-with-quarkus>quarkus  ext add resteasy-jackson
[SUCCESS] Extension io.quarkus:quarkus-resteasy-jackson has been installed

Code:

package com.ibm.rs;

//Entity
public class User {
    private  int userId;
    private  String userName;

    public User() {
    }

    public User(int userId, String userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}

package com.ibm.rs;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/users")
public class UserResource {
    //send json
    @GET
    @Path("/list")
    @Produces(MediaType.APPLICATION_JSON)
    public User findUser() {
        User user = new User(1, "Subramanian Murugan");
        return user;
    }
}

Note:
  Quarkus applies hot reloading feature, when we add extension, that means we dont need to restart server even after adding any dependency.
...........................................................................................
				JAX-RS Parameters
...........................................................................................
@MatrixParam 
   Extracts the value of a URI matrix parameter.
@QueryParam 
  Extracts the value of a URI query parameter.
@PathParam 
  Extracts the value of a URI template parameter.
@CookieParam
  Extracts the value of a cookie.
@HeaderParam
  Extracts the value of a header.
@Context
  Injects an instance of a supported resource
	

package com.ibm.rs.params;

package com.ibm.rs.params;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/api/myproducts")
public class ProductResource {

    //http://localhost:8080/api/products/10
    @Path("/{productId}")
    @GET
    public String findById(@PathParam("productId") String productId) {
        return productId;
    }

    //http://localhost:8080/product/filter?category=sports
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") String category) {
        System.out.println("");
        return category;
    }

    //Matrix Params
    //http://localhost:8080/api/myproducts/product;name=book;title=Java
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/product")
    public String getBookDetails(@MatrixParam("name") String name, @MatrixParam("title") String title) {
        System.out.println("");
        return name + " " + title;
    }
}


package com.ibm.rs.params;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;

@Path("/api/containerResource")
public class ContainerResouces {

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/urls")
    public String getUriInfo(@Context UriInfo uriInfo) {
        System.out.println(uriInfo.getAbsolutePath() + " " + uriInfo.getRequestUri());
        return uriInfo.getAbsolutePath() + " " +uriInfo.getRequestUri();
    }

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/headers")
    public String getHeaders(@Context HttpHeaders headers) {
        System.out.println(headers.getRequestHeaders());
        return "headers Information";
    }
}

Other Paramters:

1.FormParameters
@FormParam @Form
2.CookieParameter
@CookieParam
.............................................................................................
				  DefaultValues for Path

if you dont pass Query parameters ,the default values can be assigned.

//localhost:8080/api/myproducts/filter => output phone
//localhost:8080/api/myproducts/filter?category=books => output books

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") @DefaultValue("phone") String  category) {
        System.out.println("");
        return category;
    }
.............................................................................................
Assignment -1: 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection
.............................................................................................
				 Response Types
.............................................................................................

JAX-RS api can return any of one the type
 - String  - plain/text
 - Objects - application/json
 - Void    - no return type -  only status
 - Response - Response Object 


Basic Response Types: String,void,Object
package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook(){
        return "Book";
    }

    @GET
    @Path("/show")
    public void showBook(){
        System.out.println("show Book");
    }
    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook(){
        return new Book("Quarkus");
    }
}


Recommendations:

1.You can use String
2.Dont use void
3.YOu can use Object as response type


Limitions of Object as Response

-if you want to customize the Response we cant,for eg if you want to add some custom headers
like tokens,urls,resourceinformation.

Reponse Object

Response;

 Object used to send "payload-data" along with meta data (http code,otherinformation)

HTTP Status codes:

-> informational response - 100 to 199
-> success response -  200-299
-> Redirects  - 300-399
-> client errors - 400-499
-> server errrors - 500-599

Response:

Response class is abstract class contains two category of api

public abstract Object getEntity();
public abstract int getStatus();


Builder Class:

public static ResponseBuilder status(int status)
public static ResponseBuilder ok()
public static ResponseBuilder ok(Object entity)
public static ResponseBuilder created()
public static ResponseBuilder accepted()
public static ResponseBuilder noContent()

package com.ibm.rs.response.type;

import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON)
    public Response save() {
        Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}

How to post json to REST API(Save)

package com.ibm.rs.response.type;

public class Book {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Book() {
    }

    public Book(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                '}';
    }
}

package com.ibm.rs.response.type;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/api/books")
public class BookResource {

    @GET
    @Path("/list")
    public String getBook() {
        return "Book";
    }

    //    @GET
//    @Path("/show")
//    public void showBook() {
//        System.out.println("show Book");
//    }
    @GET
    @Path("/show")
    public Response showBook() {
        System.out.println("show Book");
        return Response.noContent().build();
    }

    @GET
    @Path("/sendBook")
    @Produces(MediaType.APPLICATION_JSON)
    public Book sendBook() {
        return new Book("Quarkus");
    }

    @GET
    @Path("/bookresponse")
    public Response sendBookResponse() {
        return Response.
                status(200)
                .entity(new Book("Quarkus Response"))
                .header("author", "Subramanian")
                .build();
    }

    @Path("/save")
    @POST
    @Produces(MediaType.APPLICATION_JSON) //output type
    @Consumes(MediaType.APPLICATION_JSON)  //input type
    public Response save(Book book) {
        //Book book = new Book("Vertx");
        //books/create/1  201 created
        return Response.created(UriBuilder.fromResource(BookResource.class)
                        .path("/create/" + Long.toString(1)).build())
                .entity(book)
                .header("book", book.getName())
                .build();
    }
}
.............................................................................................
................................................................................................				Status Codes And RestFul Api Design
..............................................................................................
Status Code : 100 to 500

1XX Information Responses

100 Continue
101 Switching Protocols
102 Processing
103 Early Hints

2XX Success

200 OK
201 Created
202 Accepted
203 Non-Authoritative Information
204 No Content
205 Reset Content
206 Partial Content
207 Multi-Status
208 Already Reported
226 IM Used

3XX Redirection
300 Multiple Choices
301 Moved Permanently
302 Found
303 See Other
304 Not Modified
305 Use Proxy
306 Switch Proxy
307 Temporary Redirect
308 Permanent Redirect

4XX Client errors

400 Bad Request
401 Unauthorized
402 Payment Required
403 Forbidden
404 Not Found
405 Method Not Allowed
406 Not Acceptable
407 Proxy Authentication Required
408 Request Timeout
409 Conflict
410 Gone
411 Length Required
412 Precondition Failed
413 Payload Too Large
414 URI Too Long
415 Unsupported Media Type
416 Range Not Satisfiable
417 Expectation Failed
418 I'm a teapot
420 Method Failure
421 Misdirected Request
422 Unprocessable Entity
423 Locked
424 Failed Dependency
426 Upgrade Required
428 Precondition Required
429 Too Many Requests
431 Request Header Fields Too Large
451 Unavailable For Legal Reasons

5XX Server errors
500 Internal Server error
501 Not Implemented
502 Bad Gateway
503 Service Unavailable
504 gateway Timeout
505 Http version not supported
506 Varient Also negotiate
507 Insufficient Storage
508 Loop Detected
510 Not Extended
511 Network Authentication Required
..............................................................................................
				  Negoation
..............................................................................................

What is Negoation?
 Agreeement between server and client what they can serve.

if client asks server that give me xml, means the server should able to give xml, if not it will give  response- not able to process your.

Content negotiation allows for an HTTP server to respond to different types of clients.

Many modern clients expect a JSON response, but there may be a need to format responses differently, maybe XML for older clients or a binary format for newer ones.


If the server is unable to provide the desired format, it will respond with a status code of 406, ‚ÄúNot Acceptable.‚Äù

Types of Negoation:

1.Content-Negotation
2.Language Negoation
3.Encoding Negoation


How to implement  Negotation?

Via Headers


Client Request:

Accept-*

Content Negotation
Accept: application/json,application/xml;

Language Negotation:
Accept-Language: fr

Encoding Negotation:
Accept-Encoding : gzip,deflate
..............................................................................................

Negotitation is just like a dialog between client and server.


At a high level, the conversation looks like this:

Client:
Hey Server!
I‚Äôd like to look at https://api.example.com/user/123.
I need your response in JSON.

	Server:
No Problem Client! Here is that response‚Ä¶‚Äã


Client:
Hey Server! I need https://api.example.com/user/123, preferably in JSON!
But, üò© I‚Äôll take XML if that‚Äôs all you have.
I also need the info in English or French.
Oh, please zip up the contents too.

GET /user/123 HTTP/1.1
Accept: application/json,application/xml;q=0.9
Accept-Encoding: gzip
Accept-Language: en,fr
Host: api.example.com
User-Agent: Client/2.0


Server:
Hey Client!
All I have is XML (sorry about that), the response is in English,
and I was able to zip it; here you go‚Ä¶‚Äã

                                        HTTP/1.1 200 OK
                                        Content-Type: application/xml
                                        Content-Encoding: gzip
                                        Content-Language: en

                                        <user id="123">
                                          ...
                                        </user>

..............................................................................................
Negotiation is bi directional.

Client ask with help of "Accept -*" Headers, Server will resonse with "Content-*" Headers

package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }
}


http://localhost:8080/negotiation/content

Could not find MessageBodyWriter for response object of type: com.ibm.rs.User of media type:
application/xml;charset=UTF-8


Steps:
1.Add new Dependency /extension


quarkus  ext add resteasy-jaxb
 <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-jaxb</artifactId>
</dependency>

2.We have to add @XmlRootElement

package com.ibm.rs;

import javax.xml.bind.annotation.XmlRootElement;

//Entity
@XmlRootElement
public class User {
    private  int userId;
    private  String userName;

    public User() {
    }

    public User(int userId, String userName) {
        this.userId = userId;
        this.userName = userName;
    }

    public int getUserId() {
        return userId;
    }

    public void setUserId(int userId) {
        this.userId = userId;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }
}

3.REST api which supports multi format
package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }
}

3.How to test api with multi format 

open postman or any http client.

send request

URL -http:localhost:8080/negotiation/content
Method - GET
Client/Request HTTP Headers: Accept : application/json or Accept : application/xml

Response :
Request : Accept:application/json
Status : 200 OK
{
    "userId": 1,
    "userName": "admin"
}

Request : Accept: application/xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<user>
    <userId>1</userId>
    <userName>admin</userName>
</user>

Request: Accept :application/atom+xml

Response would be 
406 Not Acceptable
The server not able to send response what client is looking for.

Client uses Accept-* header

Server uses Content-* header
..............................................................................................
				 When Client Sends Data to Server
..............................................................................................

Client is sending data in the form of json / xml or any format, server should able to process that.
content-type and annotation

@Consumes - It defines the server acceptable content.
    @POST
    @Path("/create")
    @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response create(User user) {
        System.out.println("User " + user);
        return Response.status(201).entity("Created").build();
    }
..............................................................................................
..............................................................................................						HTTP encoding
.............................................................................................

What is Content Encoding?

 if Server sends data, it can send directly

Compression Algorthim:

1.gzip
2.deflate

How to enable compression algorithm in quarkus?

By default Quarkus web container does not enable compression feature, we need to enable it.

application.properties file
  You can configure global setting for application.
quarkus.http.enable-compression=true
quarkus.resteasy.gzip.enabled=true
quarkus.resteasy.gzip.max-input=10M


package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

@Path("/negotiation")
public class ContentNegotiationResource {
    @GET
    @Path("/content")
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response negotiateContent() {
        User user = new User(1, "admin");
        return Response.ok(user).build();
    }

        @POST
        @Path("/create")
        @Consumes({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
        public Response create(User user) {
            System.out.println("User " + user);
            return Response.status(201).entity("Created").build();
        }
}


Request:

GET    /localhost:8080/negotiation/content
Accept-Encoding :gzip

Response:
content-encoding :gzip
content-length:54

..............................................................................................
			    Language Negotation
.............................................................................................

How Quarkus can give data in various data language formats. - Internatlazation and locationazation.

package com.ibm.rs.negotiation;


import com.ibm.rs.User;

import javax.ws.rs.*;
import javax.ws.rs.core.*;
import java.util.List;
import java.util.Locale;

@Path("/negotiation")
public class ContentNegotiationResource {
    //language
    // GET /negotiation/lang
    //Accept-language : en

    @Path("/lang")
    @GET
    public Response getLang(@Context Request request) {

        List<Variant> variants = Variant.VariantListBuilder
                .newInstance()
                .languages(Locale.ENGLISH, Locale.GERMAN)
                .build();


        Variant variant = request.selectVariant(variants);

        if (variant == null) {
            return Response.notAcceptable(variants).build();
        }
        String language = variant.getLanguageString();
        return Response.ok(language)
                .header(HttpHeaders.CONTENT_LANGUAGE, language)
                .build();
    }
}

Request

Request:

GET    /localhost:8080/negotiation/lang
Accept-language :en    or de

Response:
content-language : en
.............................................................................................
			        Resource Locators and Sub Resources
............................................................................................

Objective:
 if you are designing rest api for various resources,if you want to design centeralized request processing.

eg:
 CustormerResource
 PaymentResource 
 CardResource
 UserResource
 ProductResource

eg:
Normal request and response flow

Client----GET  /api/customer----------------------CustomerResource
Client----GET  /api/payment-----------------------PaymentResource

Using Resouce Locators

Client----GET  /api/customer----------------------              CustomerResource
						Application --|
Client----GET  /api/payment-----------------------               PaymentResource
                                                    |                |
                                                 main Resource    SubResources   
 


Main Resouce:
package com.ibm.rs.resoucelocators;

import javax.ws.rs.Path;

@Path("/api/ibm")
public class Application {
    //payment
    @Path("/payments")
    public PaymentResource getPaymentResource() {
        return new PaymentResource();
    }
    //Services
    @Path("/services")
    public ProductService getProductService(){
          return new ProductService();
    }
}

Sub Resouces:
package com.ibm.rs.resoucelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class ProductService {
    @GET
    public String getPayments() {
        return "Service  resource";
    }
    @GET
    @Path("{id}")
    public String getPaymentById(@PathParam("id") String id) {
        return "Services resource by id" + id;
    }
}
package com.ibm.rs.resoucelocators;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

public class PaymentResource {
    @GET
    public String getPayments() {
        return "Payment resource";
    }
    @GET
    @Path("{id}")
    public String getPaymentById(@PathParam("id") String id) {
        return "Payments resource by id" + id;
    }
}

Errors can be reported to a client either by creating and returning the appropriate
Response object or by throwing an exception.

Response Types:

1.SUCCESS Response
2.ERROR Response

How to handle / Convert ERRORS/Exceptions into HTTP Response Object?

 public Response getResponse(){

     return Response.ok().build();
 }

According to Application, Exception can be

1.System Exception :
  Exception thrown by jvm - NumberFormat,NullPointerException,ClassCastException.

2.Application Exception
   
  UserNotFoundException
  PasswordMissMatchException
  ...
public boolean validate(){

  if(passwordmatch){


  }
  else{ 
       throw new PasswordMismatchException("password does not match");
  } 
}
JAX-RS also provides the javax.ws.rs.WebApplicationException. 
This can be thrown by application code and automatically processed by JAX-RS without
having to write an explicit mapper.

WebApplicationException can be converted into Response Object.

Thrown exceptions are handled by the JAX-RS runtime if you have registered an exception mapper. 
Exception mappers can convert an exception to an HTTP response. 
If the thrown exception is not handledby a mapper, it is propagated and handled by the container (i.e., servlet) JAX-RS is running within.


package com.ibm.rs.exceptionhandling;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;

@Path("/myerrros")
public class ErrorResource {
    @GET
    @Path("{id}")
    public Response getResponse(@PathParam("id") String id) {
        if (id.equals("100")) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return Response.ok("Sucess" + id).build();
    }
}

if you run this code with  

GET  /localhost:8080/myerrors/100
2022-04-04 11:47:02,439 ERROR [org.jbo.res.res.i18n] (executor-thread-0) RESTEASY002010: Failed to execute: javax.ws.rs.WebApplicationException: HTTP 404 Not Found
        at com.ibm.rs.exceptionhandling.ErrorResource.getResponse(ErrorResource.java:15)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass.getResponse$$superforward1(Unknown Source)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass$$function$$1.apply(Unknown Source)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.proceed(AroundInvokeInvocationContext.java:54)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.proceed(InvocationInterceptor.java:62)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor.monitor(InvocationInterceptor.java:49)
        at io.quarkus.arc.runtime.devconsole.InvocationInterceptor_Bean.intercept(Unknown Source)
        at io.quarkus.arc.impl.InterceptorInvocation.invoke(InterceptorInvocation.java:41)
        at io.quarkus.arc.impl.AroundInvokeInvocationContext.perform(AroundInvokeInvocationContext.java:41)
        at io.quarkus.arc.impl.InvocationContexts.performAroundInvoke(InvocationContexts.java:32)
        at com.ibm.rs.exceptionhandling.ErrorResource_Subclass.getResponse(Unknown Source)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:566)
        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:170)
        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:130)
        at org.jboss.resteasy.core.ResourceMethodInvoker.internalInvokeOnTarget(ResourceMethodInvoker.java:660)
        at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTargetAfterFilter(ResourceMethodInvoker.java:524)
        at org.jboss.resteasy.core.ResourceMethodInvoker.lambda$invokeOnTarget$2(ResourceMethodInvoker.java:474)
        at org.jboss.resteasy.core.interception.jaxrs.PreMatchContainerRequestContext.filter(PreMatchContainerRequestContext.java:364)
/////////////////////////////////////////////////////////////////////////////////////////////

The above error we need to handle by converting into response.

In order to convert Exception into Proper Response, JAX-RS provides , Mapper class.

Mapper class will convert any expception into Success like Response, so that it wont throw any Errors.

Exception Mapper class:

Steps:

1.You have to declare Mapper class

2.You have to annotate with @Provider Annotation.

@Provider
public class WebApplicationMapper {
}

3.You have to extends ExceptionMapper<ExceptionType>


package com.ibm.rs.exceptionhandling;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
//
//class CustomerIdNotFoundException extends RuntimeException {
//     public CustomerIdNotFoundException(){
//            super();
//     }
//    public CustomerIdNotFoundException(String message){
//        super(message);
//    }
//}
//
//@Provider
//class CustomerExceptionMapper implements ExceptionMapper<CustomerIdNotFoundException> {
//    @Override
//    public Response toResponse(CustomerIdNotFoundException e) {
//        return null;
//    }
//}

@Provider
public class WebApplicationMapper implements ExceptionMapper<WebApplicationException> {
    @Override
    public Response toResponse(WebApplicationException e) {
        // return Response.noContent().build();
        return Response.status(404)
                .entity(e.getMessage())
                .header("err", e.getResponse()
                        .getStatus()).build();
    }
}
..............................................................................................
				  Dependency Injection - IOC
..............................................................................................

What is IOC?
 Inversion of Control is design pattern for creating depandent objects and injecting into another.

How IOC is implemented in Spring?
 Spring Container is the reference implemnetation of IOC design pattern

How IOC is implemented in Quarkus?
  Quarkus uses JEE spec called CDI context Dependency Injection

What is CDI?
  CDI is JEE Spec? -Jakarta Contexts and Dependency Injection

Quarkus and CDI ?
 Quarkus has not implemented 100% CDI spec due to some reasons.

  "Quarkus ArC" is a build-time oriented dependency injection based on CDI 2.0.

JEE CDI Vs Quarkus CDI:
......................

JEE CDI "resolves" bean dependency during runtime of an application,after deployment, if something goes wrong, errors are reported only during runtime.

Quarkus CDI uses a model called "Build Time"
   During application build process, if there is any dependency missmatch related errors are reported.

Build-time Processing Benefits and Drawbacks:
..............................................

Fail Fast
  Beans and dependencies are validated during the build so that your application can never fail in production with common problems such as AmbiguousResolutionException or UnsatisfiedResolutionException.

Instant Startup
  When the app starts ArC just loads all the metadata and initializes some internal structures. There is no need to analyze the application classes again. This means negligible startup overhead.
 
Minimized Runtime
  In Quarkus 0.19, ArC plus integration runtime consist of 72 classes and occupies ~ 140 KB in jars. Weld 3.1.1 (CDI Reference Implementation) core is roughly 1200 classes and approx. 2 MB jar. In other words, ArC runtime takes approx. 7% of the Weld runtime in terms of number of classes and jar footprint.

Optimized Code Paths and Metadata Structures
  When generating the metadata classes ArC can sometimes produce leaner and smarter logic because it has the whole application analyzed already. 

Core Features of CDI:

1.Bean: What is Bean?
  Bean is java object

Types of Beans:

1.Application Beans(pojos)
   Objects are created by developer 
   Objects life cycle is managed by developer and JVM

2.Container managed Bean
   Objects created by the Container

What is container?
   Container is runtime where quarkus apps are running.
 
  Object life cycle are managed by Runtime 

What are the advantages of Container Managed Bean?

>The developer can focus application logic.
.............................................................................................
				 CDI implemenation

CDI is implemented via "Annotations"

Apis in cdi:

1.javax.inject
2.javax.enterprise.inject - core di apis
3.javax.enterprise.context - scope and contextuaal apis
4.javax.enterprise.events -  publishing events and listening events-  container wide event driven programming
5.javax.enterprise.util
6.javax.interceptor

Common Annoations:

1.@Inject  
2.@Qualifer
3.LifeCycle of Bean
   @ApplicationScoped
   @SessionScoped
   @RequestScoped
   @SingleTon
 
4.@Observes - event listner


package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

//Bean
@ApplicationScoped
public class HelloService {
    public String sayHello() {
        return "Hello!!!";
    }
}


package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/greeter")
public class GreeterResource {
    //DI - field
    @Inject
    private HelloService helloService;

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
............................................................................................

Assignment -2: 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

New Features to be added:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI
.............................................................................................
   				CDI and Resource Locator


if a sub resouces has CDI annotation, if there  is any dependency.we need to use different annotations.

Main Resource

Old style:
    @Path("/services")
    public ProductService getProductService(){
          return new ProductService();
    }
This code will not work , which will throw NullPointerException, the reason is CDI build time process. here object creation happens runtime.

Solution;
@Context - It is used to inject any container specific features.

ResourceContext :
      Get a resolved instance of a resource or sub-resource class.

The resolved resource instance is properly initialized in the context of the current request processing scope.

 The scope of the resolved resource instance depends on the managing container. For resources managed by the runtime container the default scope is per-request.


Resource:
package com.ibm.rs.resoucelocators;

import com.ibm.rs.di.GreeterResource;

import javax.ws.rs.Path;
import javax.ws.rs.container.ResourceContext;
import javax.ws.rs.core.Context;

@Path("/api/ibm")
public class Application {
    @Context
    ResourceContext resourceContext;
   
    @Path("/greeter")
    public GreeterResource getGreeterResource(){
        return resourceContext.getResource(GreeterResource.class);
    }
}

package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
    //DI - field
    @Inject
    private HelloService helloService;

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
..............................................................................................

			Bean Creation Exception-UnsatisfiedResolutionException


javax.enterprise.inject.UnsatisfiedResolutionException: Unsatisfied dependency for type com.ibm.rs.di.HelloService and qualifiers [@Default]
	- java member: com.ibm.rs.di.GreeterResource#helloService
	- declared on CLASS bean [types=[com.ibm.rs.di.GreeterResource, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.GreeterResource]
	at io.quarkus.arc.processor.Beans.resolveInjectionPoint(Beans.java:428)
	at io.quarkus.arc.processor.BeanInfo.init(BeanInfo.java:524)
	at io.quarkus.arc.processor.BeanDeployment.init(BeanDeployment.java:260)
	at io.quarkus.arc.processor.BeanProcessor.initialize(BeanProcessor.java:134)
	at io.quarkus.arc.deployment.ArcProcessor.validate(ArcProcessor.java:462)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)


This exception is thrown when bean is not created -  
  due to 
    -no bean class  not present in the class path
    -you may forgot to annotate using lifecycle annotations -@ApplicationScoped...


eg:
public class HelloService {

      public String sayHello(){
           return "Hello Service Bean";
      }
}
 @Inject
 HelloService helloService;

..............................................................................................
                            Types of Injection in Quarkus  -Inection Points

1.Field Injection
2.Setter Injection
3.Constructor injection


Setter Injection
package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
   //setter injection
    private HelloService helloService;

    @Inject
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}

///
constructor injection:
package com.ibm.rs.di;

import javax.enterprise.context.RequestScoped;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@RequestScoped
public class GreeterResource {
    //DI - field
//    @Inject
//    private HelloService helloService;

    //setter injection
//    private HelloService helloService;
//
//    public GreeterResource() {
//    }

    //constructor Injection
    private HelloService helloService;

    //    @Inject
//    public GreeterResource(HelloService helloService) {
//        this.helloService = helloService;
//    }

//without Inject annotation also works
    public GreeterResource(HelloService helloService) {
        this.helloService = helloService;
    }

//

    @GET
    @Path("/hello")
    public Response sayHello() {
        return Response.ok(helloService.sayHello()).build();
    }
}
.............................................................................................
				Quarkus and Type based Implementation 
.............................................................................................

Quarkus is always based on type based injection not implemenation based.

Steps : 1 declare interface.

package com.ibm.rs.di;

public interface NumberGenerator {
    //Generate ISBN Number
    String generateNumber();
}

Step 2:  implement interface
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import java.util.Random;

@ApplicationScoped
public class IsbnGenerator implements NumberGenerator {
    @Override
    public String generateNumber() {
        return "15-87654" + Math.abs(new Random().nextInt());
    }
}

Step 3: declare book Service:
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

@ApplicationScoped
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}

Step 5: Declare Book Resource
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/api/book")
public class BookResource {
    @Inject
    BookService bookService;

    @GET
    public Response createBook(){
        return Response.ok(bookService.createBook()).build();
    }
}
..............................................................................................
			   Interface DI with Mulitiple Implementations
..............................................................................................


Step : 1 declare interface
package com.ibm.rs.di;

public interface Greeter {
    String sayGreet();
}

Step 2 : declare multiple implementations

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class Hai implements Greeter {
    @Override
    public String sayGreet() {
        return "Hai";
    }
}

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class Hello implements Greeter {
    @Override
    public String sayGreet() {
        return "Hello";
    }
}

Step 3: Resource Class with Greeter Dependency

package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/greeter/greet")
public class GreeterDIResource {
    @Inject
    private Greeter greeter;

    @GET
    public String sayGreet() {
        return greeter.sayGreet();
    }

}

When you run this code , you will get 

javax.enterprise.inject.AmbiguousResolutionException: Ambiguous dependencies for type com.ibm.rs.di.Greeter and qualifiers [@Default]
	- java member: com.ibm.rs.di.GreeterDIResource#greeter
	- declared on CLASS bean [types=[java.lang.Object, com.ibm.rs.di.GreeterDIResource], qualifiers=[@Default, @Any], target=com.ibm.rs.di.GreeterDIResource]
	- available beans:
		- CLASS bean [types=[com.ibm.rs.di.Greeter, com.ibm.rs.di.Hello, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.Hello]
		- CLASS bean [types=[com.ibm.rs.di.Hai, com.ibm.rs.di.Greeter, java.lang.Object], qualifiers=[@Default, @Any], target=com.ibm.rs.di.Hai]

here we need to tell the quarkus which implementation bean you want.


How to solve this problem?

Qualifiers
   Injecting Qualified beans which you want bean implemenation you want.

Is there any default qualifier?

Yes

@Default

if there is only one implementation, injection works using @Default qualifier.

if there is more than one implementation , container will throw AmbiguousResolutionException

How to write Qualifier?

We have to write custom  Qualifer annotation

Steps: 

1.Qualifier for Hai
import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface HaiQualifier{
}

2.Qualifier for Hello

package com.ibm.rs.di;

import javax.inject.Qualifier;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Qualifier
@Retention(RUNTIME)
@Target({FIELD,TYPE,METHOD})
public @interface HaiQualifier{
}


3.Annotate Bean classes with Qualifiers

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@HelloQualifier
@ApplicationScoped
public class Hello implements Greeter {
    @Override
    public String sayGreet() {
        return "Hello";
    }
}
package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;

@HaiQualifier
@ApplicationScoped
public class Hai implements Greeter {
    @Override
    public String sayGreet() {
        return "Hai";
    }
}

4.Inject beans into service or resource
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/greeter/greet")
public class GreeterDIResource {

    //this works only if there is only one implementation
//    @Inject @Default
//    private Greeter greeter;
//    @Inject
//    @HaiQualifier
//    private Greeter haigreeter;
//
//    @Inject
//    @HelloQualifier
//    private Greeter hellogreeter;

    //code refactoring without @Inject itself it works
    @HaiQualifier
    private Greeter haigreeter;

    @HelloQualifier
    private Greeter hellogreeter;

    @GET
    public String sayGreet() {
        return haigreeter.sayGreet() + " " + hellogreeter.sayGreet();
    }

}
...........................................................................................
				Bean Scopes
...........................................................................................
1.@ApplicationScoped
     Bean is created and kept entire life of application
     Only one time is created - singleton
     A single bean instance is used for the application and shared among all injection points. 
     The instance is created lazily, i.e. once a method is invoked upon the "client proxy".

2.@SingleTon
      -only one instance per container

Applicationscope vs singleton

-singleton beans are eagerly created
-application beans are lazy - uses a factory -client proxy
-singleton is some what performance good.Applicationscope uses delegation pattern to delegate  objects to proxy classes
-Singletons cant be used to create Mock using QuarksMock under test

     
2.Request,Session
   -A bean can be bound to single request cycle-  mostly used in  dynamic webapps
    eg: Spring MVC,Struts
   -Session scope 
     single user multiple requests.

@RequestScoped :
  In the subresource if you refer resource inside MainResource.

PaymentApp
    -
     @RequestScoped
     CreditCardResource
..............................................................................................
..............................................................................................
			Types of beans with respect to data injection
..............................................................................................

1.class beans
  ...variables and methods itself can be treated as dependency
2.Producer methods
3.Producer fields
.....................
4.Syntenetics beans


1.class Bean:
  Bean is created out class.

@ApplicationScoped
public class BookService {} 

@Inject
BookService bookService

2.Producer fields  && Producer methods
   We can inject any instance variable and methods as dependency.

package com.ibm.rs.di;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import java.util.ArrayList;
import java.util.List;

@ApplicationScoped
public class Producers {
    //instance variable ; going to be as dependency to some other classes
    @Produces
    double price = 1000.00;

    //instance method ; going to be as dependency to some other class
    @Produces
    List<String> topics(){
        List<String> topics = new ArrayList<>();
        topics.add("cdi");
        topics.add("configuration");
        topics.add("RestEasy");
        return topics;
    }
}
package com.ibm.rs.di;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;
import java.util.List;

@Path("/producer")
public class ProducerDI {

    @Inject
    double price;
    @Inject
    List<String> topics;


    @GET
    @Path("/price")
    public Response getPrice() {
        return Response.ok().entity(price).build();
    }
    @GET
    @Path("/topics")
    public Response getTopics() {
        return Response.ok().entity(topics).build();
    }
}
..............................................................................................
				Life cycle Hooks and Beans
.............................................................................................

@PostConstruct
@PreDestroy

package com.ibm.rs.di;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Singleton;

@ApplicationScoped
//@Singleton
public class BookService {

    //Inject interface
    @Inject
    NumberGenerator numberGenerator;
    
    @PostConstruct
    public void init(){
        System.out.println("INIT");
    }
    @PreDestroy
    public void destroy(){
        System.out.println("Destroy");
    }

    //biz method
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
}
..............................................................................................
				  Interceptors
..............................................................................................
    
What is concern?
   concern means features like transaction,security,logging

Cross cutting means, removing these concerns from the application logic.

How to cross cutting concerns?
 There is spec all "java interceptors" 

How to define interceptor and bind with api?

Step 1: 
Define custom Annotation and annotate with @InterceptorBinding , which is going to act as bridge between "Interceptor" and Service biz logic.

package com.ibm.rs.di.interceptors;

import javax.interceptor.InterceptorBinding;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Inherited
@InterceptorBinding
@Retention(RUNTIME)
@Target({METHOD, TYPE})
public @interface LogEvent {
}

Step 2: define Interceptor

Declare class and annotate with @Interceptor

Have method and annotate with @AroundInvoke - gets called when ever biz method is called
Bind With @LogEvent -  InterceptorBinding Annotation

package com.ibm.rs.di.interceptors;

import javax.interceptor.AroundInvoke;
import javax.interceptor.Interceptor;
import javax.interceptor.InvocationContext;
import java.util.logging.Logger;

@Interceptor
@LogEvent
public class BookServiceInterceptor {

    private Logger logger;

    @AroundInvoke
    public Object logEvent(InvocationContext invocationContext) throws Exception {
        logger = Logger.getLogger(invocationContext.getTarget().getClass().getName());
        System.out.println("log.........");
        logger.info("Method: " + invocationContext.getMethod().getName());
        logger.info("Arguments: " + invocationContext.getParameters());
        logger.info("Executing the called method");
        Object possibleReturn = invocationContext.proceed();
        logger.info("The object the method was invoked on:" + invocationContext.getTarget().getClass().getName());

        return possibleReturn;

    }
}

Step 3: Inside service, you have to annotate with InterceptorBindinAnnotation
    @LogEvent
    public Book createBook() {
        Book book = new Book("Quarks In Action", 1000f, "Subramanian");
        book.setIsbn(numberGenerator.generateNumber());
        return book;
    }
   @GET
    @LogEvent
    public String sayGreet() {
        return haigreeter.sayGreet() + " " + hellogreeter.sayGreet();
    }
..............................................................................................
..............................................................................................
                           Private keyword on Dependency field

Quarkus and its native image generation performs better CDI work without private members. Dependency injection requires a lot of Reflection API usage, which is very expensive. In the interest of generating better-performing native images, don‚Äôt use the private modifier for fields. Stick with package-level access for class-level variables.
......................................
Quarkus-Only Enhancements to CDI Quarkus enriches its implementation of CDI in ArC, by adding the following features, among others.
.............................................................................................

Assignment -3 : 
 You have to build book Resource

/api/books
=>FindAll books
=>findBook by isbn, author
=>filter books by category and language - userinterface,microservices
=>save new book 
=>remove existing book - by isbn
=>update book information

Model : isbn,author,title,publisher,dateofpublishing,edition

Database: in memory datastructure -  List or Set or Map - Findout approiate collection

Features:

->Resource Locators  
->The api should return data in two formats - XML and JSON -negoation
->Exception Handling
   ->Suppose if given bookid not available
  Add : Resouce Specific Exception class 
        Global Exceptions
->Add BookService Layer , keep all book apis,From Rest api you have to call service methods
  Use DI

New Features to be added:

1.Generate 16 digit ISBN and 32 digit ISBN code via ISBN Generator class
2.Inject ISBNGenerator ServiceBean into BookService - Which ISBN Digit you want- DI
3.Inject book authors and price as DI into BookService class
4.You have to write interceptor for BookService Bean to watch the book operations 

















  
























